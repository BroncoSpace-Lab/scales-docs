{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SCALES!","text":""},{"location":"FlatSat_Development/","title":"FlatSat Development","text":"<p>This document is an overview of the current and future state of our FlatSat development for SCALES.</p>"},{"location":"FlatSat_Development/#current-updates","title":"Current Updates","text":""},{"location":"FlatSat_Development/#direct-ethernet-connection","title":"Direct Ethernet Connection","text":"<p>We are currently able to connect the boards directly in the following configuration:</p> <p></p> <p>From there, we have to set a temporary ip on the iMX, in this case it is set to 10.3.2.6 so we can ping the Jetson's ip.</p> <p></p> <p>We can also use the iMX to ssh into the Jetson:</p> <p></p> <p>And we can do the same process of pinging the iMX and ssh from the Jetson:</p> <p></p> <p></p> <p>We are also able to copy files from the iMX to the Jetson. In this example, we copied a file called mcp9808a from the iMX to the Jetson:</p> <p></p>"},{"location":"FlatSat_Development/#satcat","title":"SatCat","text":"<p>We are currently only able to use SatCat to send/recieve messages from different serial ports within the same windows host computer. </p> <p>We followed this example setup from SatCat's GitHub to download the software onto the FPGA and set up the hardware in the following configuration: </p> <p></p> <p>With the python chat client, we were able to get data transfer speeds on both UART and Ethernet:</p> <p></p> <p></p> <p>This provided example only allows connection from SatCat to the COM ports of the local computer used, and NOT connection between different systems (which is what we need). This example also only supports one ethernet and one UART, and we would prefer to have 2 ethernet ports available. We tried using a UART to ethernet converter, but it didn't work. We believe this is mainly due to the verilog programmed onto the FPGA only being able to handle UART protocol for that port, so this is something we will have to look into as well. </p> <p>Next Step: Develop Verilog code to enable communication between two different external systems (Jetson to the flight computer) and communicate via two ethernet ports.</p>"},{"location":"FlatSat_Development/#voxl2","title":"VOXL2","text":"<p>The VOXL2 is currently bricked after attempting to update the software using the command \"voxl-configure-mpa\".</p> <p>We followed the unbricking tutorial numerous times and encountered issues with VOXL's firmware files that fail to call on its own files when flashing the board. We submitted a ticket to the ModalAI forum two weeks ago and havent heard back.</p> <p>The error we are receiving when attempting to flash the board is shown below:</p> <p></p> <p>Next Step: Reach out to ModalAI to get more assistance from the team to help debug.</p>"},{"location":"FlatSat_Development/#imx-8x","title":"iMX 8X","text":"<p>For more details, take a look at documentation.</p> <p>Main updates:</p> <ul> <li>successfully re-flashed the operating system to a Yocto Linux kernel</li> <li>set up the SDK on a Linux host computer to cross compile code</li> <li>got an I2C sensor up and running with a C code executable file to read sensor data on the board</li> <li>able to copy code from GitHub instead of using as USB every time</li> <li>figured out how to run python code on the board</li> <li>started trying to get F Prime up and running on board</li> </ul> <p>Development Environment</p> <p>To run python code on the iMX, any python code file can be marked as executable and run on the board. For example, the following hello world python script runs as expected on the iMX: <pre><code>#!/usr/bin/env python\n\nprint(\"Hello, World!\")\n</code></pre> The setup and output on the board looks like this:</p> <p></p> <p>For other languages including C and C++, code must be cross-compiled in the SDK on the Linux Host machine. We have currently tested this using both C and C++ code and compiliers. After the code is cross-compiled in the SDK, it generates an executable file that can be run on the iMX. For more information on the cross-compilation process, reference the I2C Interfacing Guide from our docs. In that guide, we cross-compile C code to read data from an I2C temperature sensor and output the result in terminal on the board. </p> <p>PhyTEC Guide Experience</p> <p>The guides from PhyTEC for this board are a bit rough to work with at times. Many of the issues we ran into during development were due to a lack of description and detail in the docs and guides. We mainly found that the guides are great at getting you started, but lack the explaination on how many of these interfaces and protocols can be used outside of basic setup. Some interfacing guides are better than others, though, and others can sometimes be outdated. There are also not many tutorials on compiling code, the only examples shown compile C++ code. This is something that may become a challenge later on in development. </p> <p>However, it is worthy to note that phyTEC's support team does reply quickly and consistently, usually within 1-2 days and with helpful feedback, which makes development a little easier. </p> <p>F Prime Development</p> <p>We are in the process of getting F Prime deployed on the iMX. We made a discussion post on the F Prime GitHub going over our process and the current issues we have. We have recieved some feedback that will be looked into in the next few days.</p> <p>Ideally we can get F Prime up and running in the next week or so, that way we can use it for real-time data transmission between boards instead of just copying over files over ethernet. </p>"},{"location":"FlatSat_Development/#future-flatsat-plan","title":"Future FLATSAT Plan","text":"<p>General Goals</p> <ul> <li>set up static ip address on the iMX</li> <li>fix F Prime deployment on the iMX</li> <li>set up sensor data transfer from iMX to Jetson using F Prime</li> <li>change SatCat verilog to work with external systems</li> <li>change SatCat verilog to work with ethernet instead of UART</li> <li>get the VOXL to work</li> <li>create a unified power system</li> <li>right now, all FlatSat components are plugged into wall outlets, so we need to begin development on the power distribution block of the overall system architecture</li> <li>ideally, we will be able to power the system with one source that is regulated and distributed to the proper components</li> </ul> <p>After viewing the full capabilities of our chosen FPGA, we are currently comparing three different hardware architectures for our SCALES system:</p>"},{"location":"FlatSat_Development/#architecture-1","title":"Architecture 1","text":"<p>Architecture 1 has sensors attached to the flight computer.</p> <p></p> <p>Pros:</p> <ul> <li>Lower power consumption from internal system (less ethernet ports)</li> <li>immediate sensor logging</li> <li>eliminates bandwidth limitation by having seperate data streams for each sensor</li> </ul> <p>Cons:</p> <ul> <li>slightly longer sensor data transferring from the flight computer to the Jetson</li> <li>requires FPGA software development and custom FPGA board</li> </ul>"},{"location":"FlatSat_Development/#architecture-2","title":"Architecture 2","text":"<p>Architecure 2 has sensors attached to SATCAT</p> <p></p> <p>Pros:</p> <ul> <li>Sensor data is accesible to both the flight computer and Jetson</li> <li>5 GigEthernet Ports</li> <li>22 Low speed ports (SPI, I2C, UART, CAN)</li> <li>slightly faster sensor data transfer directly from SatCat to Jetson</li> </ul> <p>Cons:</p> <ul> <li>requires heavily modified FPGA software and custom FPGA board</li> <li>requires extra 2W to power all ports</li> <li>bandwidth limitation</li> </ul>"},{"location":"FlatSat_Development/#architecture-3","title":"Architecture 3","text":"<p>Architecure 2 has no SATCAT and has sensors attached to the flight computer</p> <p></p> <p>Pros:</p> <ul> <li>easiest architecture to develop</li> <li>lowest power consumption</li> <li>no FPGA development</li> <li>one less source error</li> </ul> <p>Cons:</p> <ul> <li>less communication ports</li> <li>more development needed on flight computer board (to enable more ethernet ports)</li> </ul>"},{"location":"FlatSat_Development/#testing-metrics","title":"Testing Metrics","text":"<p>These are the test metrics that will help make hardware design decisions:</p> <ul> <li>lowest power consumption</li> <li>will be tested at component level and system level during different tasks including real-time inferencing and data transfer</li> <li>data transfer speed</li> <li>ease of use</li> <li>hardware setup: How many internal connections are required? How long did it take to set up?</li> <li>software setup: How much manual input do we have to put in to get the system to work? How long do certain critical tasks take?</li> <li>amount of manual input/labor</li> <li>read/write ability: Are there any issues when flight computer and Jetson are trying to access the data at the same time?</li> <li>availability of I/O</li> </ul> <p>Test Procedure</p>"},{"location":"ML_Jetson_Performance/","title":"Machine Learning Model Inference Performance","text":"<p>This document will go over the performance of the Jetson AGX Orin 64 Dev Kit while inferecing over a variety of different common models. This is supposed to provide a reference baseline for developers to gather and understanding of how their models may performa on the SCALES system.</p>"},{"location":"ML_Jetson_Performance/#models-tested","title":"Models Tested","text":"<ul> <li> <p>Resnet-152</p> <ul> <li>Image classification</li> <li>Model Card</li> <li>Parameters: 60.3M</li> </ul> </li> <li> <p>Depth Anything V2</p> <ul> <li>Depth Estimation </li> <li>Model Card</li> <li>Parameters: 97.5M</li> </ul> </li> <li>YOLO V8<ul> <li>Image Classification</li> <li>Model Card</li> <li>Parameters: 3.2M</li> </ul> </li> <li>Phi-3.5<ul> <li>Language Model</li> <li>Model Card</li> <li>Parameters: 3.82B</li> </ul> </li> </ul>"},{"location":"ML_Jetson_Performance/#reference-missions","title":"Reference Missions","text":"<p>There is a couple of reference missions that can be represented through the use of the above models and play a factor in why they were choosen to conduct testing on. </p> <p>Mission 1:   Using Classification Models  Clssification Models are used to basically group images to certain \"classes\" this can be very useful onboard spacecraft because you can use them to filter incoming data streams to see if the images have target objects in them. A great example is with Earth Observation Satellites users want to know if the image taken has cloud cover in it or not, most customers buying imagery do not want to have clouds in their imagery as it increases the complexity of proccessing and provides less data. Classification algorithims running onboard can anazle the live stream of imagery or saved imagery to indentify cloud coverage in images and then priotrize downlinking the images without clouds in them. </p> <p>Mission 2:   Using Depth Models  Depth Esetmation models are used to estimate how far something is using camera imagery. This has many uses cases in space applications. The first is in RPO missions where cameras can be used to determine how far apart two spacecraft are and in real time update how two spacecraft are moving. The speed of depth estimation algorithims is quite benficial in time dependent situations like docking. </p> <p>Mission 3:   Using LLMs</p> <p>LLMs are large language models that are used to converse in natural language and syhtensize data. As far as we are currently aware there hasnt been an active technology demonstration of these modesl deployed in space but they are very new and we believe there is a path to use in the future. We currently see use cases in basically allowing the satellites to have conversations with ground operators being able to ingest all the information about the satellite and then the user can ask questions about the state of the spacecraft and get a response in natural language. This is a longer timeline mission case but we felt like it was important to run a test using the one of the newest archetectures of models for developer refernce as the use of LLMs is expanding at a rapid pace. </p>"},{"location":"ML_Jetson_Performance/#procedure","title":"Procedure","text":"<p>Models were choosen from the hugging face model hub and then completed inference tests on the jetson. The hugging face transformer pipeline api as well as data sets were used to crate the inference enviroment and data. </p> <p>The data was collected using the tegrastats data parser which is able to read all the metrics from the jetson and save all the data into a csv file while also plotting some of the key metrics. </p> <p>If interested in other metrics Tegrastats records all of the following metrics:</p> <ul> <li>Time</li> <li>Used RAM</li> <li>Total Ram</li> <li>Number of Free RAM Blocks</li> <li>Size of Free RAM Blocks</li> <li>Used SWAP</li> <li>Total SWAP</li> <li>Cached SWAP</li> <li>CPU Frequency</li> <li>CPU 0-11 Load %</li> <li>Used GR3D %</li> <li>GR3D Frequency</li> <li>CPU Temperature</li> <li>tboard Temperature</li> <li>Temperature </li> <li>tdiode Temperature</li> <li>tj Temperature</li> </ul> <p>Each of the models were tested at all 4 of the Jetson power modes to show performance in resource constrained enviroments</p>"},{"location":"ML_Jetson_Performance/#data-set-description","title":"Data Set Description","text":"<p>The CIFAR100 is a commonly used dataset that contaains 50000 training images and 10000 test images that have corresponding labels that align to 100 different classes. The classes are completly mutually exlculsive. The data set is further broken down into smaller batches for each of the training and test sets. The test batch of images contains ramdonly selected images from all of the different classes in equal amounts. The training batch may have unequal amounts of each classes. Each images is only 32x32 pixels making them very small images basically thumbnail size. The purpose of using this dataset was that it was a small data set that was able to run quickly on the jetson for all the different model types. The team could conduct testing with larger size images but the general jist of performance will stay the same. Bigger images means longer run times. </p>"},{"location":"ML_Jetson_Performance/#resnet-results","title":"Resnet Results","text":"<p>The resnet model was tested using the CIFAR100 dataset.The team used the test split to inference 10,000 images.</p> <p>Resnet Test Results</p> Test Average FPS Average GPU % Average RAM (MB) Total Inference Time (s) Power Draw (W) MaxN 21.015 59.07 7905.32 475.03 14.78 50W 15.27 52.39 10161.1 655.08 12.18 30W 16.91 61.29 4255.58 591.32 12.72 15W 10.64 72.35 3882.09 939.46 10.16"},{"location":"ML_Jetson_Performance/#raw-data","title":"Raw Data","text":"<ul> <li>MaxN Raw Data</li> <li>50W Raw Data</li> <li>30W Raw Data</li> <li>15W Raw Data</li> </ul>"},{"location":"ML_Jetson_Performance/#graphs","title":"Graphs","text":""},{"location":"ML_Jetson_Performance/#maxn-data","title":"MAXN Data","text":""},{"location":"ML_Jetson_Performance/#50w-data","title":"50W Data","text":""},{"location":"ML_Jetson_Performance/#30w-data","title":"30W Data","text":""},{"location":"ML_Jetson_Performance/#15w-data","title":"15W Data","text":""},{"location":"ML_Jetson_Performance/#depth-anything-results","title":"Depth Anything Results","text":"<p>The resnet model was tested using the CIFAR100 dataset.The team used the test split to inference 1,000 images.</p> <p>Depth Anything Test Results</p> Test Average FPS Average GPU % Average RAM (MB) Total Inference Time (s) Power Draw (W) MaxN 5.25 45.98 4453.77 190.54 21.25 50W 3.71 90.62 4967.38 269.25 27.78 30W 1.53 93.67 4665.56 655.45 15.13 15W 0.83 95.95 4903.13 1198.83 11.91"},{"location":"ML_Jetson_Performance/#raw-data_1","title":"Raw Data","text":"<ul> <li>MaxN Raw Data</li> <li>50W Raw Data</li> <li>30W Raw Data</li> <li>15W Raw Data</li> </ul>"},{"location":"ML_Jetson_Performance/#graphs_1","title":"Graphs","text":""},{"location":"ML_Jetson_Performance/#maxn-data_1","title":"MAXN Data","text":""},{"location":"ML_Jetson_Performance/#50w-data_1","title":"50W Data","text":""},{"location":"ML_Jetson_Performance/#30w-data_1","title":"30W Data","text":""},{"location":"ML_Jetson_Performance/#15w-data_1","title":"15W Data","text":""},{"location":"ML_Jetson_Performance/#phi-3-results","title":"Phi-3 Results","text":"<p>Phi-3 Test Results</p> Test Tokens/s Average GPU % Average RAM (MB) Total Generation Time (s) Power Draw (W) MaxN 3.66 60.78 11248.46 131.55 13.99 50W 3.60 49.75 10200.76 133.48 12.54 30W 3.83 63.74 12136.26 125.59 14.07 15W 2.6 52.31 10752.25 184.66 11.33"},{"location":"ML_Jetson_Performance/#graphs_2","title":"Graphs","text":""},{"location":"ML_Jetson_Performance/#maxn-data_2","title":"MAXN Data","text":""},{"location":"ML_Jetson_Performance/#50w-data_2","title":"50W Data","text":""},{"location":"ML_Jetson_Performance/#30w-data_2","title":"30W Data","text":""},{"location":"ML_Jetson_Performance/#15w-data_2","title":"15W Data","text":""},{"location":"ML_Jetson_Performance/#notes","title":"Notes","text":"<ul> <li> <p>The jetson power modes are designed to optimize for power draw which can limit the upper end of performance. For example when running the Phi-3 model in MaxN mode the GPU was running at the minium frequency of 300 Mhz and gets the 3.72 tokens/second. If the user is to manually edit the power modes to set the GPU frequency to the max of 1.3 GHz the jetson is able to produce ~8 tokens/second of performance. Now the downside is that you jump from ~20W of power draw to ~50W but this is an operational trade off between uptime and speed. </p> </li> <li> <p>From the previous note we have noticed that this performance is only acheived on some models. This might be because of implemenation methodolies but for example we saw large performance increases with the phi-3 model but for the resnet and depth anything there was no impactful change in performance even when the GPU frequency was manually increased. </p> </li> <li> <p>There may be other settings for each power mode that can continue to improve performance of models. The metrics data primarly use the default power states of of the Jetson</p> </li> <li> <p>There is a weird discrpancy in the NVIDIA documentation about the AGX Orin Power modes. So all the testing for this file has been done on a 32GB version of the AGX orin and the documentation says that there should be a 40W mode but there is only a 50W mode which is the documentation for the 64gb version of the board. additionally this board is having the max gpu frequency that is only supposed to be on the 64Gb version. So worried about the consistecny of the results on a 64gb board. </p> </li> </ul> <p>Things to do still </p> <ul> <li>Flash and test everything on a 64gb Jetson AGX Orin</li> <li>Yolo V8 inference testing</li> <li></li> </ul>"},{"location":"ML_Training/","title":"Machine Learning Model Training Performance","text":""},{"location":"ML_Training/#model-trained","title":"Model Trained","text":"<ul> <li>Resnet-50 </li> </ul> <p>Was set up to train over the CIFAR100 data set where there is 50,000 training images and 10,000 test images. These images are labeled with 100 different classes. Resnet is a classification model so this data set meets its needs perfectly. The models were only trained up to 10 epochs purely in the conservation of time since this testing is producing results on hardware performance and not model accucary. Users could extrapolate time and resource utilization to train a model to completion from the test results. These results are just to serve as a basline so developers have a commonly used reference model to base their expectations around in terms of onboard performance. </p>"},{"location":"ML_Training/#training-results","title":"Training Results","text":"<p>Resnet Training Performance Results</p> Test Average Time/Epoch Average GPU % Average RAM (MB) Total Training Time Test Accuary Power Draw (W) MaxN (P) 2:12 94.03 9539.33 22:08 41.84% 51.03 MaxN (S) 2:11 92.86 7965.45 22:19 42.66% 50.36 50W 2:44 94.56 8467.51 28:22 37.68% 34.23 30W 5:05 95.97 7907.65 52:27 39.17% 21.60 15W 10:34 84.18 7868.99 1:46:40 32.07% 13.62 <ul> <li>(P) denotes that the power mode was adjusted to hit maximum GPU frequency</li> <li>(S) denotest the use of the standard power mode configuration</li> <li>Note: When conducting this training run the standard mode did automatically increase the GPU frequency to the max to accomidate the large computational load</li> </ul>"},{"location":"ML_Training/#notes","title":"Notes","text":"<p>The GPU has a different max frequency at each power mode that effects performance.</p> <p>Unlike inferencing when training the Jetson seems to default to using the max frequency allocation for each power mode to get the most performance possible for the very intenisve task</p> <p>Frequencies:  MaxN - 1.3 GHZ  50W - 828 MHz 30W - 612 MHz 15W - 408 MHz</p>"},{"location":"Test%20Procedure%20List/","title":"Testing Procedure Script","text":"<p>This document will create a mock DRM test to run on both the VOXL2 and IMX8. This document also includes individual component testing and system level testing according to the DRM.</p>"},{"location":"Test%20Procedure%20List/#mock-drm","title":"Mock DRM","text":"<p>sensors:</p> <ul> <li>SPI: HUMIDITY SENSOR</li> <li>I2C: TEMP SENSOR</li> <li>UART: IMU</li> <li>Ethernet: CAMERA</li> <li>USB: CAMERA</li> <li>CAN: PHOTORESISTIVE SENSOR</li> <li>GPIO: WATCHDOG</li> </ul> <p>Mock Mission:</p> <ul> <li>FILL IN</li> </ul> <p>FC Tasks:</p> <ul> <li>constantly monitor atmosphere using I2C, SPI, UART</li> </ul>"},{"location":"Test%20Procedure%20List/#fc-individual-testing","title":"FC Individual Testing","text":""},{"location":"Test%20Procedure%20List/#1-communication-testing","title":"1. Communication Testing","text":"<p>Objective: We will be verifying each communication protocol individually by taking in sensor data and writing to memory. We will then perform the same test, but with all protocols running at the same time. We will be keeping note on runtime, bandwidth and power draw.</p> <p>Test Equipment:</p> <ul> <li>Flight Computer (IMX8 dev board / VOXL2 dev board)</li> <li>Sensors for each communication protocol (SPI, I2C, UART, Ethernet, USB, CAN, GPIO)</li> <li>variety of jumper wires</li> </ul> <p>FPrime Component and Commands (need to be developed):</p> <ul> <li>Component: REALTIME_DATA_PROCESSING</li> <li>Description: This component will have commands that take data from sensors and write it to the flight computer's memory for 30 seconds<ul> <li>Commands: (individual commands to start each protocol for 30 sec, and one multi-communication command for 30 sec)</li> <li>SPI_START</li> <li>I2C_START</li> <li>UART_START</li> <li>ETHERNET_START</li> <li>USB_START</li> <li>CAN_START</li> <li>GPIO_START</li> <li>ALL_START</li> <li>Telemetry Channels:<ul> <li>sensorState</li> <li>sensorValue</li> <li>runtime</li> <li>bandwidth</li> <li>powerDraw</li> </ul> </li> </ul> </li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? Data transfer doesnt write to memory writes to memeory ? individual functionality not every protocol works every protocol works ? multi-sensor functionality no/partial functionality full functionality ? runtime ? bandwidth ? power draw ? <p>Procedure:</p> <ul> <li>wire all sensors to the filght computer</li> <li>run REALTIME_DATA_PROCESSING FPrime deployment and start GDS</li> <li>run SPI_START command</li> <li>Measure runtime, bandwidth, powerdraw, etc.</li> <li>verify data was written into memory</li> <li>Repeat this process to each command listed below:</li> <li>I2C_START: TEMP SENSOR</li> <li>UART_START: IMU</li> <li>Ethernet_START: CAMERA</li> <li>USB_START: CAMERA</li> <li>CAN_START: PHOTORESISTIVE SENSOR</li> <li>GPIO_START: WATCHDOG</li> <li>ALL_START: starts all sensor data collection</li> </ul>"},{"location":"Test%20Procedure%20List/#2-power-testing","title":"2. Power Testing","text":"<p>Objective: We will be observing different power states of both flight computers (high, middle, low, overclocked, underclocked, idle) to obtain a better understanding of how much power each flight computer will generally use. To do this, we will be using cpuburn to activate different percentages(100%, 50%, and 10%) of the cpu's cores and the power consumption at each percentage. For over and under clocking, we will manually set the clockspeed of the cpu to (clockspeed-0.4GHz) for underclocking and (clockspeed+0.2GHz) for overclocking. For the idle state, we will turn flight computer on with no tasks running and observe power consumption.</p> <p>Test Equipment:</p> <ul> <li>Flight Computer (IMX8 dev board / VOXL2 dev board)</li> </ul> <p>Pass/Fail Criteria:</p> Test Result Notes high power state 100% Draw: high power state 50% Draw: high power state 10% Draw: Low power state 100% Draw: Low power state 50% Draw: Low power state 10% Draw: Undeclock state 100% Draw: Undeclock state 50% Draw: Undeclock state 100% Draw: Overclocking state 100% Draw: Overclocking state 50% Draw: Overclocking state 10% Draw: Idle Draw: <p>Procedure:</p> <ul> <li>download cpuburn on the flight computer</li> <li>Test high power draw by running ./cpuburn and record power draw</li> <li>Test medium power draw by running ./cpuburn -n 2 and record power draw</li> <li>Test low power draw by running ./cpuburn -n 1 and record power draw</li> <li>Test overlocking by setting clock speed to (clockspeed+0.2GHz) and record power draw</li> <li>Test underclocking by setting clock speed to (clockspeed-0.4GHz) and record power draw</li> <li>Test Idle by turning flight computer on with no tasks running and record power draw</li> </ul>"},{"location":"Test%20Procedure%20List/#3-watchdog-testing","title":"3. Watchdog Testing","text":"<p>Objective: We will be verifying the functionality of an external watchdog timer circuit with our flight computers. We will observe what the WDT does at 5 seconds, 5+0.2 seconds, and 5-0.2 seconds to ensure that the WDT is resetting at 5sec properly.</p> <p>Test Equipment:</p> <ul> <li>Flight Computer (IMX8 dev board / VOXL2 dev board)</li> <li>external watchdog timer circuit</li> <li>jumper wires</li> </ul> <p>FPrime Component and Commands (need to be developed):</p> <ul> <li>Component: WATCHDOG</li> <li>Description: This component will serve as the trigger for an external watchdog circuit.<ul> <li>Commands: (GPIO on/off timers)</li> <li>GPIO_ON (turns gpio pin on)</li> <li>GPIO_OFF (turns gpio pin off)</li> <li>GPIO_ON_5SEC (toggles gpio pin ever 5 seconds)</li> <li>GPIO_ON_4.8SEC (toggles gpio pin ever 4.8 seconds)   -GPIO_ON_5.2SEC (toggles gpio pin ever 5.2 seconds)</li> <li>Telemetry Channels:<ul> <li>gpioState</li> </ul> </li> </ul> </li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? 5sec cycle WDT does reset FC WDT does NOT reset FC ? 4.8sec cycle WDT does reset FC WDT does NOT reset FC ? 5.2sec cyle WDT does NOT reset FC WDT does reset FC ? <p>Procedure:</p> <ul> <li>Attach watchdog circuit to FC</li> <li>run WATCHDOG FPrime deployment and start GDS</li> <li>run the command GPIO_ON </li> <li>Wait 15 seconds and verify FC stays ON</li> <li>run the command GPIO_OFF</li> <li>wait and verify FC RESETS (this should be about 5 seconds)</li> <li>run the command GPIO_ON_5SEC</li> <li>wait 15 seconds and verify FC stays ON</li> <li>run the command GPIO_ON_4.8SEC</li> <li>wait 15 seconds and verify FC stays ON</li> <li>run the command GPIO_ON_5.2SEC</li> <li>wait 10 seconds and verify FC RESETS</li> </ul>"},{"location":"Test%20Procedure%20List/#jetson","title":"Jetson","text":""},{"location":"Test%20Procedure%20List/#1-power-testing","title":"1. Power Testing","text":"<p>Objective: We will be observing different power states of the Jetson AGX Orin (high, middle, low, overclocked, underclocked, idle) to obtain a better understanding of how much power it will generally use. To do this, we will use different percentages of gpu burn to test high, middle, and low power states. For over and under clocking, we will manually set the clockspeed of the cpu to (clockspeed-0.4GHz) for underclocking and (clockspeed+0.2GHz) for overclocking. For the idle state, we will turn the Jetson on with no tasks running and observe power consumption.</p> <p>Test Equipment:</p> <ul> <li>Jetson AGX Orin</li> </ul> <p>Pass/Fail Criteria:</p> Test Result Notes MAXN state 100% Draw: MAXN state 50% Draw: MAXN power state 10% Draw: 50W power state 100% Draw: 50W power state 50% Draw: 50W power state 10% Draw: 30W power state 100% Draw: 30W power state 50% Draw: 30W power state 10% Draw: 15W power state 100% Draw: 15W power state 50% Draw: 15W power state 10% Draw: Undeclock state 100% Draw: Undeclock state 50% Draw: Undeclock state 100% Draw: Overclocking state 100% Draw: Overclocking state 50% Draw: Overclocking state 10% Draw: Idle Draw: <p>Procedure:</p> <ul> <li>download gpu burn on the Jetson (https://github.com/wilicc/gpu-burn)</li> <li>open Jetson Power GUI to obtain power draw in the duration of this test</li> <li>Test high power draw by running 'gpu_burn -m 100' and record power draw</li> <li>Test medium power draw by running 'gpu_burn -m 50' and record power draw</li> <li>Test low power draw by running 'gpu_burn -m 10' and record power draw</li> <li>Test overlocking by setting clock speed to (clockspeed+0.2GHz) and record power draw</li> <li>Test underclocking by setting clock speed to (clockspeed-0.4GHz) and record power draw</li> <li>Test Idle by turning Jetson on with no tasks running and record power draw</li> </ul>"},{"location":"Test%20Procedure%20List/#first-system-level-test-fc-and-jetson-only","title":"First System Level Test (FC and Jetson Only)","text":""},{"location":"Test%20Procedure%20List/#1-fc-to-jetson-watchdog-timer-test","title":"1. FC to Jetson Watchdog Timer Test","text":"<p>Objective: We will be verifying that the FC is able to act as the Jetson's watchdog timer. This will be done by connecting a GPIO pin from the FC to the Jetson, which will have the Jetson send a pulse every 5 seconds to the FC to reset a digital counter on the FC. The Jetson will also be connected to the FC through its reset pin, which allows the FC to reset the Jetson if the Jetson stops sending a pulse through the GPIO pin. This test will test the case when the Jetson stops sending a pulse, which will force the FC to reset the Jetson.</p> <p>Test Equipment:</p> <ul> <li>Flight computer (IMX8 dev board / VOXL2 dev board)</li> <li>Jetson</li> <li>variety of jumper wires</li> </ul> <p>FC and Jetson Scripts: (need to be developed)</p> <ul> <li>The FC will have a script that will have a counter. One the counter reaches 5 seconds, it will pull the reset button on the Jetson high to reset the Jetson. This counter will reset to zero when the FC recieves a pulse from the GPIO pin from the Jetson.</li> <li>The Jetson will have a script that will send a pulse through the GPIO pin every 4 seconds.</li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? 5sec cycle FC does reset Jetson FC does NOT reset Jetson ? 4.8sec cycle FC does reset Jetson FC does NOT reset Jetson ? 5.2sec cyle FC does NOT reset Jetson FC does reset Jetson ? <p>Procedure:</p> <ul> <li>Connect the FC and Jetson. This includes the GPIO pin and the RST pin</li> <li>Wait 15 seconds and verify Jetson stays ON</li> <li>Change the Jetson script to send a pulse every 4.8 seconds</li> <li>wait 15 seconds and verify Jetson stays ON</li> <li>Change the Jetson script to send a pulse every 5.2 seconds</li> <li>wait 10 seconds and verify Jetson RESETS</li> </ul>"},{"location":"Test%20Procedure%20List/#2-fc-to-jetson-reflashing-test","title":"2. FC to Jetson Reflashing Test","text":"<p>Objective: We will be verifying that the FC is capabable of reflashing the Jetson. We will do this by connecting the FC to the Jetson through USB, and running a script that will reflash the Jetson.</p> <p>Test Equipment:</p> <ul> <li>Flight computer (IMX8 dev board / VOXL2 dev board)</li> <li>Jetson</li> <li>USB to USB-C Cable</li> </ul> <p>Reflash Script: (needs to be developed)</p> <ul> <li>The reflash script will run commands that will reflash the Jetson.</li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? Reflash capability unable to relfash successfully reflash ? <p>Procedure:</p> <ul> <li>Connect the FC to the Jetson using the USB cable</li> <li>Run the reflash script on the FC</li> <li>Verify that the Jetson Reflashes</li> </ul>"},{"location":"Test%20Procedure%20List/#final-system-level-test-fc-satcat5-and-jetson","title":"Final System Level Test (FC, SatCat5, and Jetson)","text":""},{"location":"Test%20Procedure%20List/#1-data-transfer-test","title":"1. Data Transfer Test","text":"<p>Objective: We will be verifying ethernet switching capability on the Arty A7 FPGA dev board between a FC and Jetson. To do this, we will have data collected from a sensor connected to a FC. That FC will be connected through ethernet to SatCat5, where it will relay the data to the Jetson through ethernet as well. Then, the data recieved on the Jetson will be echoed back to the FC and save it to the FC's memory.</p> <p>Test Equipment:</p> <ul> <li>SatCat5 FPGA dev board</li> <li>Jetson</li> <li>flight computer (IMX8 dev board / VOXL2 dev board)</li> <li>2x ethernet cables</li> <li>1x Ethernet PMod connector</li> <li>sensor (for data)</li> </ul> <p>FPGA Script (need to be developed):</p> <ul> <li>Description: This script needs to define 2 ethernet gates where the laptop and FC will be plugged into. The code will create a pathway for the two to talk to each other and pass over data in realtime.</li> </ul> <p>Flight Computer and Jetson Script (need to be developed):</p> <ul> <li>The flight computer that will start the sensor data and send it through its ethernet port, and also to recieve data and write it down in its memory. </li> <li>The Jetson script will recieve data from its ethernet port, save it, and echo it back to the flight computer.</li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? full system functionality system does not transfer data from FC to Jetson and vice versa system is able to transfer data between FC and Jetson and vice versa ? Jetson Writing Jetson is unable to write data received from FC Jetson successfully writes data received from FC ? transfer speed noticable lag no noticeable lag ? SatCat5 functionality SatCat5 stops working during data transfer SatCat5 runs with no issues during data transfer ? <p>Procedure:</p> <ul> <li>connect sensor to the flight computer</li> <li>connect the Jetson and FC to the FPGA using ethernet cables</li> <li>program the FPGA </li> <li>start data transfer scripts on both the flight computer and Jetson</li> <li>wait 30 seconds and verify the data saved on the Jetson and flight computer</li> </ul>"},{"location":"Test%20Procedure%20List/#2-total-power-test","title":"2. Total Power Test","text":"<p>Objective: We will be oberving the overall power draw of the entire system including the FC, SatCat5, and Jetson. We will do this by running the data transfer test (the test right above this test) and monitor the power draw levels on the FC, SatCat5, and Jetson. We will add up the power draw from each of these components to obtain the overall power draw of the sytem.</p> <p>Test Equipment:</p> <ul> <li>SatCat5 FPGA dev board</li> <li>Jetson</li> <li>flight computer (IMX8 dev board / VOXL2 dev board)</li> <li>2x ethernet cables</li> <li>1x Ethernet PMod connector</li> <li>sensor (for data)</li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? Overall Power Draw over # under # ? <p>Procedure:</p> <ul> <li>Connect the FC, SatCat5, and Jetson together</li> <li>Run the same procedure listed under the Data Transfer Test above</li> <li>Monitor and record power draw from the FC, SatCat5, and Jetson</li> <li>Sum the power draws together to obtain the overall power draw</li> </ul>"},{"location":"Test%20Procedure%20List/#3-full-fprime-to-fprime-communication-test","title":"3. Full FPrime-to-FPrime Communication Test","text":"<p>Objective: We will verify the communication between the FC and the Jetson with FPrime running on both of the systems. We will do this by having the FC FPrime deployment pull telemetry channel data through the Jetson's FPrime Deployment and vice versa.</p> <p>Test Equipment:</p> <ul> <li>SatCat5 FPGA dev board</li> <li>Jetson</li> <li>flight computer (IMX8 dev board / VOXL2 dev board)</li> <li>2x ethernet cables</li> <li>1x Ethernet PMod connector</li> <li>sensor (for data)</li> </ul> <p>FPrime Component and Commands (need to be developed):</p> <ul> <li>Component: ?</li> <li> <p>Description: ?</p> <ul> <li>Commands:</li> <li> <p>?</p> </li> <li> <p>Telemetry Channels:</p> <ul> <li>?</li> </ul> </li> <li>Component: ?</li> <li>Description: ?</li> <li>Commands:</li> <li> <p>?</p> </li> <li> <p>Telemetry Channels:</p> <ul> <li>?</li> </ul> </li> </ul> </li> </ul> <p>Pass/Fail Criteria:</p> Test FAIL PASS yes/no? FC to Jetson Communication FC unable to retreive data FC able to retreive data ? Jetson to FC Communication Jetson unable to retreive data Jetson able to retreive data ? <p>Procedure: - Connect the FC, SatCat5, and Jetson together - Run the respective FPrime deployments on the FC and Jetson - Run the GDS's for the FC deployment and the Jetson deployment - (need help on Alex's side to finish the rest of the procedure and making the right components on FPrime)</p>"},{"location":"imx8x_procedures/","title":"i.MX 8X Testing Procedures","text":"<p>This document lists the interfacing and testing procedures required to get the i.MX 8X development board up and running for SCALES.</p> <p>Important note: It is ideal to be using a 64-bit Linux host machine as opposed to Windows or a virtual machine. An ARM Cortex Linux machine will not work (cannot use a Jetson as host computer for development). </p>"},{"location":"imx8x_procedures/#yocto-linux-bsp","title":"Yocto Linux BSP","text":"<p>It is very important to be using a 64-bit host computer with Ubuntu 18.04 installed. Any other version - especially newer versions of Ubuntu - will not build the BSP properly.</p> <p>We followed this guide to build the BSP. This documentation, as of February 2025, does not work properly on it's own. </p>"},{"location":"imx8x_procedures/#build-errors","title":"Build Errors","text":"<p>At first, you may encounter some build errors while trying to run the <code>bitbake imx-image-multimedia</code> command in the \"Start the Build\" section of the guide. Most of these errors result from mistakes in the importing of other files and libraries in the code. To remedy this, we took the following steps:</p> <ol> <li>Open <code>...BSP-Yocto-FSL-i.MX8X-PD21.1.0/sources/poky/bitbake/lib/bb/compat.py</code> on your host computer and make the import lines near the beginning of the code match the following:</li> </ol> <pre><code>from collections.abc import MutableMapping, KeysView, ValuesView, ItemsView\nfrom collections import OrderedDict\nfrom functools import total_ordering\n</code></pre> <p>Here, the change is to change the first import from <code>collections</code> to <code>collections.abc</code>, and to add the line <code>from collections import OrderedDict</code>.</p> <ol> <li>Open <code>.../BSP-Yocto-FSL-i.MX8X-PD21.1.0/sources/poky/bitbake/lib/bb/persist_data.py</code> and match the beginning on your code to the following:</li> </ol> <pre><code>import collections\nimport collections.abc\nimport logging\nimport os.path\nimport sys\nimport warnings\nfrom bb.compat import total_ordering\nfrom collections.abc import Mapping\nimport sqlite3\nimport contextlib\n\nsqlversion = sqlite3.sqlite_version_info\nif sqlversion[0] &lt; 3 or (sqlversion[0] == 3 and sqlversion[1] &lt; 3):\n    raise Exception(\"sqlite3 version 3.3.0 or later is required.\")\n\n\nlogger = logging.getLogger(\"BitBake.PersistData\")\n\n@total_ordering\nclass SQLTable(collections.abc.MutableMapping):\n</code></pre> <p>Here, the change is adding the <code>import collections.abc</code> line and modifying the last line shown here to include <code>collections.abc.MutableMapping</code>.</p> <ol> <li>Open <code>.../BSP-Yocto-FSL-i.MX8X-PD21.1.0/sources/poky/bitbake/lib/bb/data_smart.py</code> and match your import section to the following:</li> </ol> <pre><code>import copy, re, sys, traceback\nfrom collections.abc import MutableMapping\nimport logging\nimport hashlib\nimport bb, bb.codeparser\nfrom bb   import utils\nfrom bb.COW  import COWDictBase\n</code></pre> <p>Here, the change is to add the line <code>from collections.abc import MutableMapping</code>.</p> <p>After fixing those errors, there was another one that came up when trying to build:</p> <p></p> <p>Phytec support gave us the following guidance:</p> <p>Here is a patch for fixing the dependencies.</p> <p>The imx8x is on an older BSP. Github has deprecated anonymous use of the git protocol so the fetching is failing. This patch adds .bbappend files for all the failing recipes.</p> <p>The bbappends files update the SRC_URI to use the https protocol, as well as define the main branch instead of master, which has been deprecated.</p> <p>Applying the Patch</p> <p>To apply the patch you will want to make a file called 0001-Fix-SRC_URI-git-protocol-changed.patch in your meta-phytec folder. We used nano to do this.</p> <pre><code>cd Yocto/sources/meta-phytec/\nnano 0001-Fix-SRC_URI-git-protocol-changed.patch\n</code></pre> <p>In the file you just created, paste the following and then save and exit the nano editor.</p> Click to toggle the patch file code. <pre><code>From 21b454eafb3a5a61963a6d8ff53fdd8a8bd2a565 Mon Sep 17 00:00:00 2001\nFrom: Garrett Giordano &lt;ggiordano@phytec.com&gt;\nDate: Thu, 30 Jan 2025 11:38:13 -0800\nSubject: [PATCH] Fix SRC_URI git protocol changed\n\nAdded protocol=https and branch=main to the following recipes:\n - glslang\n - spirv-tools\n - bmap-tools\n - googletest\n - teseract-lang\n\nSigned-off-by: Garrett Giordano &lt;ggiordano@phytec.com&gt;\n---\n .../recipes-graphics/tesseract/tesseract-lang_%.bbappend    | 4 ++++\n .../recipes-graphics/vulkan/glslang_git.bbappend            | 5 +++++\n .../recipes-graphics/vulkan/spirv-tools_git.bbappend        | 6 ++++++\n .../recipes-support/bmap-tools/bmap-tools_%.bbappend        | 4 ++++\n .../recipes-test/googletest/googletest_%.bbappend           | 4 ++++\n 5 files changed, 23 insertions(+)\n create mode 100644 meta-phytec-fsl/recipes-graphics/tesseract/tesseract-lang_%.bbappend\n create mode 100644 meta-phytec-fsl/recipes-graphics/vulkan/glslang_git.bbappend\n create mode 100644 meta-phytec-fsl/recipes-graphics/vulkan/spirv-tools_git.bbappend\n create mode 100644 meta-phytec-fsl/recipes-support/bmap-tools/bmap-tools_%.bbappend\n create mode 100644 meta-phytec-fsl/recipes-test/googletest/googletest_%.bbappend\n\ndiff --git a/meta-phytec-fsl/recipes-graphics/tesseract/tesseract-lang_%.bbappend b/meta-phytec-fsl/recipes-graphics/tesseract/tesseract-lang_%.bbappend\nnew file mode 100644\nindex 0000000..1a34dce\n--- /dev/null\n+++ b/meta-phytec-fsl/recipes-graphics/tesseract/tesseract-lang_%.bbappend\n@@ -0,0 +1,4 @@\n+# Git has deprecated anonymous git:// protocol. Add protocol=https\n+# master branch has been changed to main. Add branch=main\n+\n+SRC_URI = \"git://github.com/tesseract-ocr/tessdata.git;protocol=https;branch=main;\"\ndiff --git a/meta-phytec-fsl/recipes-graphics/vulkan/glslang_git.bbappend b/meta-phytec-fsl/recipes-graphics/vulkan/glslang_git.bbappend\nnew file mode 100644\nindex 0000000..fa29589\n--- /dev/null\n+++ b/meta-phytec-fsl/recipes-graphics/vulkan/glslang_git.bbappend\n@@ -0,0 +1,5 @@\n+# Git has deprecated anonymous git:// protocol. Add protocol=https\n+# master branch has been changed to main. Add branch=main\n+\n+SRC_URI = \"git://github.com/KhronosGroup/glslang;protocol=https;branch=main \\\n+\"\ndiff --git a/meta-phytec-fsl/recipes-graphics/vulkan/spirv-tools_git.bbappend b/meta-phytec-fsl/recipes-graphics/vulkan/spirv-tools_git.bbappend\nnew file mode 100644\nindex 0000000..35e8bf3\n--- /dev/null\n+++ b/meta-phytec-fsl/recipes-graphics/vulkan/spirv-tools_git.bbappend\n@@ -0,0 +1,6 @@\n+# Git has deprecated anonymous git:// protocol. Add protocol=https\n+# master branch has been changed to main. Add branch=main\n+\n+SRC_URI = \"git://github.com/KhronosGroup/SPIRV-Tools.git;protocol=https;branch=main;name=spirv-tools \\\n+           git://github.com/KhronosGroup/SPIRV-Headers.git;protocol=https;branch=main;name=spirv-headers;destsuffix=${DEST_DIR}/spirv-headers \\\n+\"\ndiff --git a/meta-phytec-fsl/recipes-support/bmap-tools/bmap-tools_%.bbappend b/meta-phytec-fsl/recipes-support/bmap-tools/bmap-tools_%.bbappend\nnew file mode 100644\nindex 0000000..220a048\n--- /dev/null\n+++ b/meta-phytec-fsl/recipes-support/bmap-tools/bmap-tools_%.bbappend\n@@ -0,0 +1,4 @@\n+# Git has deprecated anonymous git:// protocol. Add protocol=https\n+# master branch has been changed to main. Add branch=main\n+\n+SRC_URI = \"git://github.com/intel/${BPN};protocol=https;branch=main\"\ndiff --git a/meta-phytec-fsl/recipes-test/googletest/googletest_%.bbappend b/meta-phytec-fsl/recipes-test/googletest/googletest_%.bbappend\nnew file mode 100644\nindex 0000000..7b95ce5\n--- /dev/null\n+++ b/meta-phytec-fsl/recipes-test/googletest/googletest_%.bbappend\n@@ -0,0 +1,4 @@\n+# Git has deprecated anonymous git:// protocol. Add protocol=https\n+# master branch has been changed to main. Add branch=main\n+\n+SRC_URI = \"git://github.com/google/googletest.git;protocol=https;branch=main\"\n-- \n2.25.1\n</code></pre> <p>You can then cd into your meta-phytec folder and apply the patch</p> <pre><code>cd sources/meta-phytec/\ngit apply 0001-Fix-SRC_URI-git-protocol-changed.patch \n</code></pre> <p>You should then be able to build the BSP using </p> <pre><code>bitbake imx-image-multimedia\n</code></pre> <p>After applying those changes, the BSP built just fine, and we were able to use balenaEtcher to flash a microSD card for the i.MX using the <code>imx-image-multimedia-imx8x-phycore-kit.sdcard.bz2</code> image created during the build found in the <code>$BUILDDIR/tmp/deploy/images/imx8x-phycore-kit/</code> directory.</p>"},{"location":"imx8x_procedures/#modifying-the-bsp","title":"Modifying the BSP","text":"<p>Following this guide to modify the BSP we built in the previous section. We did not run into any issues when following this guide.</p> <p>Add any packages from the list that you feel are relevant to your use case. When finished, you would have to re-flash the microSD card with the updated BSP and boot the i.MX with a clean install after each update.</p>"},{"location":"imx8x_procedures/#connecting-directly-to-the-imx-8x","title":"Connecting directly to the i.MX 8X","text":"<p>Connect to the dev board following the Quick Start guide. </p>"},{"location":"imx8x_procedures/#required-materials","title":"Required materials","text":"<ul> <li>i.MX 8X development board, with microUSB UART cable and power cable. </li> <li>A Windows computer with Tera Term installed (or other serial communication software.) </li> </ul>"},{"location":"imx8x_procedures/#directions","title":"Directions","text":"<ol> <li> <p>Do not power the board yet. Connect the UART debug cable to X51 UART0 on the board, and the USB part into your computer. </p> <ul> <li>There are two serial ports that are specific to the i.MX 8X. One will be the debug terminal, and the other will be the main command terminal. Each different Windows host computer will have different names for these ports, so in the next few steps the ports COM15 and COM16 are example ports from Kelly\u2019s computer. </li> <li>It is a good idea to open both serial ports that appear as options in Tera Term during your first setup, so that you know which ports are which for your specific computer. </li> </ul> </li> <li> <p>Start Tera Term (Windows computer). Select Serial COM15. Go to Setup &gt; Serial Port. Change the speed to 115200. Press OK. </p> <ul> <li>COM15 is the command terminal. To see the debug terminal, follow the same steps for COM16. </li> <li>COM15 and 16 may be different on other computers. To be safe, set up both ports on the first boot to your device. </li> <li>Make sure to set them up before powering the board, or you will miss the sign in prompt. </li> </ul> </li> <li> <p>Plug in the DC power cable to power on the board. </p> </li> <li> <p>Sign in when prompted. Password is \u201croot\u201d. </p> </li> </ol>"},{"location":"imx8x_procedures/#setting-up-host-computer","title":"Setting up Host Computer","text":"<p>Following this guide to install the SDK on the host computer. </p>"},{"location":"imx8x_procedures/#required-materials_1","title":"Required materials","text":"<ul> <li>64-bit Linux host machine. </li> </ul>"},{"location":"imx8x_procedures/#directions_1","title":"Directions","text":"<ol> <li> <p>Once the SDK is set up on the host computer, it never needs to be done again. </p> </li> <li> <p>Be sure to source the environment before doing any work on the host computer:  <pre><code>source /opt/fsl-imx-xwayland/5.4-zeus/environment-setup-aarch64-poky-linux\n</code></pre></p> </li> </ol>"},{"location":"imx8x_procedures/#setting-up-ethernet","title":"Setting up Ethernet","text":""},{"location":"imx8x_procedures/#required-materials_2","title":"Required materials","text":"<ul> <li>Windows computer with Tera Term installed </li> <li>Ethernet cable </li> <li>Router/Ethernet hub </li> <li>i.MX 8X development board </li> </ul>"},{"location":"imx8x_procedures/#directions_2","title":"Directions","text":"<ol> <li> <p>Connect an ethernet cable from the router to an ethernet hub. Then connect another ethernet cable from your computer to the hub, and a third cable from the board to the hub. </p> </li> <li> <p>Test internet connection on the board. Press Ctrl+C to end the operation after the command runs for a while. <pre><code>ping 8.8.8.8\n</code></pre></p> </li> <li> <p>Find the IP address of the board in Tera Term  <pre><code>ifconfig \n</code></pre></p> <ul> <li>The IP will be following the words \u201cinet addr\u201d under the ethernet port number you connected to. </li> <li>The following image shows the IP is 192.168.0.190 for eth0 </li> <li>This may change each time you boot the board, so be sure to check.</li> </ul> </li> </ol> <p></p> <ol> <li> <p>Run VS Code and open a WSL terminal </p> <ul> <li>Good practice is to run the following:  <pre><code>sudo apt-get update\n</code></pre></li> <li>Use <code>sudo apt-get install ssh</code> to update ssh if needed. </li> </ul> </li> <li> <p>Command to ssh into board: (make sure to update the IP)  <pre><code>ssh root@192.168.0.145 -o HostKeyAlgorithms=+ssh-rsa -o PubKeyAcceptedAlgorithms=+ssh-rsa\n</code></pre></p> </li> <li>Congrats you are now in the board on your computer. </li> </ol>"},{"location":"imx8x_procedures/#copying-files-over-to-the-board","title":"Copying files over to the board","text":"<ol> <li>Make sure the board is connected to the host computer via ethernet.</li> <li>Navigate to the directory with the file you would like to copy to the i.MX 8X. Use the following command to secure copy that file to the board. Fill in the blank for the file name and the IP address of the board. <pre><code>cd &lt;file directory&gt;\nscp -o HostKeyAlgorithms=+ssh-rsa -o PubKeyAcceptedAlgorithms=+ssh-rsa &lt;file name&gt; root@&lt;ip address&gt;:~\n</code></pre></li> <li>You should be able to see the file in the main directory of the i.MX 8X.</li> </ol>"},{"location":"imx8x_procedures/#i2c-interfacing","title":"I2C Interfacing","text":"<p>Following this guide on I2C interfacing. </p>"},{"location":"imx8x_procedures/#required-materials_3","title":"Required materials","text":"<ul> <li>MPC9808 Temp. Sensor with 4 female to female dupont wires </li> <li>i.MX 8X development board </li> <li>Windows computer with Tera Term installed </li> <li>64-bit Linux host computer </li> </ul>"},{"location":"imx8x_procedures/#hardware-setup","title":"Hardware Setup","text":"<p>Wire Legend: </p> <p>red - Vdd       black - Gnd     brown - SCL     blue - SDA </p> <p></p> <p>red goes into pin 1 of X60. </p>"},{"location":"imx8x_procedures/#directions_3","title":"Directions","text":"<ol> <li> <p>Follow instructions for setting up ethernet. The following commands can be done either in Tera Term on a Windows machine connected to the board or in terminal ssh\u2019d into the board from the Linux host computer. </p> </li> <li> <p>List the available I2C devices  <pre><code>ls /dev/i2c*\n</code></pre></p> </li> <li>Scan the board for devices  <pre><code>i2cdetect -y -r 16\n</code></pre></li> <li>Default output: (time to play spot the difference to find your device\u2019s address) </li> </ol> <p></p> <p>Expected Output</p> <p></p> <p>my output (device address is 0x18) </p> <ol> <li>In the host computer\u2019s terminal, source the correct cross-compiler for C code:  <pre><code>source /opt/fsl-imx-xwayland/5.4-zeus/environment-setup-aarch64-poky-linux\n</code></pre></li> <li>Enter the C compiler directory:  <pre><code>cd /opt/fsl-imx-xwayland/5.4-zeus/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux\n</code></pre></li> <li> <p>Run the code for the sensor:  <pre><code>sudo ./aarch64-poky-linux-gcc -mcpu=cortex-a35+crc+crypto -fstack-protector-strong -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/opt/fsl-imx-xwayland/5.4-zeus/sysroots/aarch64-poky-linux -O ~/imx8x/i2c-temp-sensor/MCP9808.c -o ~/imx8x/i2c-temp-sensor/mcp9808a\n</code></pre> Notes:</p> <ul> <li> <p>This path only works for C code. If you want to use C++, change the gcc at the beginning to g++. I am still trying to figure out how to do python code so stay tuned for that. </p> </li> <li> <p>Note: This code is from GitHub. It was listed as free to use, distributed with a free-will license (mentioned in first line of code comments). </p> </li> </ul> </li> <li> <p>This code will generate an executable file. To run this code on the board, you may choose to use a USB flash drive or pull the code from our GitHub repo: </p> </li> </ol> <p>USB:</p> <ol> <li>Copy the file to a USB and insert it in the board. Run the following commands on the board to set up the USB:  <pre><code>echo host &gt; /sys/kernel/debug/ci_hdrc.0/role\ncd /sys/class/gpio/\necho 30 &gt; export\necho out &gt; gpio30/direction\necho 0 &gt; gpio30/value\n</code></pre></li> <li>Check to make sure the sda1 is accessible by running:  <pre><code>ls /run/media/\n</code></pre></li> <li>Run the code for the sensor by running:  <pre><code>cd /run/media/sda1\n./mcp9808a\n</code></pre></li> <li>You should see the temperature readings in the terminal. </li> </ol> <p>GitHub:</p> <ol> <li> <p>The board must be connected to internet via wifi or ethernet for this method to work. </p> </li> <li> <p>Clone the scales-hardware GitHub repo to your home directory if you not previously done so. <pre><code>cd\ngit clone https://github.com/BroncoSpace-Lab/scales-hardware.git\n</code></pre></p> </li> <li>On the board navigate to the scales-hardware directory (this is a clone of our GitHub repo.) and update the repo  <pre><code>cd scales-hardware\ngit add .\ngit pull\n</code></pre></li> <li>Then navigate to the imx8x folder and (optionally) view the files there.  <pre><code>cd imx8x\nls\n</code></pre></li> <li>And run the code for the sensor in the same way as before:  <pre><code>./mcp9808a\n</code></pre></li> <li>You should see the temperature sensor readings in the terminal.</li> </ol>"},{"location":"imx8x_procedures/#f-prime-test-deployment","title":"F Prime Test Deployment","text":"<p>We created a test deployment of F Prime version 3.5 found in this repository. Make sure the host computer is connected to the i.MX 8X via ethernet.</p> <ol> <li>Use the following code to enter the F Prime directory on the host computer and source the F Prime environment: <pre><code>cd fprime/fprime-hub-pattern-example\nsource fprime-venv/bin/activate\n</code></pre></li> <li>Use the following code to enter the Test Deployment directory on the host computer and secure copy the deployment to the board. Fill in the blank with the ip address if the board: <pre><code>cd build-artifacts/imx8x/TestDeployment/bin\nscp -o HostKeyAlgorithms=+ssh-rsa -o PubKeyAcceptedAlgorithms=+ssh-rsa TestDeployment root@&lt;ip of imx8x&gt;:~\n</code></pre></li> <li>Use the following command on the i.MX 8X to run the Test Deployment: <pre><code>./TestDeployment -a 0.0.0.0 -p 50000\n</code></pre></li> <li>Use the following command on the host computer to launch the F Prime gds. Fill in the blank with the ip address if the board: <pre><code>cd ..\ncd dict/\nfprime-gds -n --dictionary TestDeploymentTopologyDictionary.json --ip-client --ip-address &lt;ip of imx8x&gt;\n</code></pre></li> </ol>"},{"location":"imx_carrier_board/","title":"i.MX 8X Custom Carrier Board","text":""},{"location":"imx_carrier_board/#design-notes","title":"Design Notes","text":"<p>This design for the i.MX 8X SCALES Custom Devlopment Board is mostly based on PhyTec's Development Kit design. For clarity, this version of the SCALES board will be called \"SCALES board\" and the PhyTec Devlopment Kit board will be called \"dev kit.\"</p> <p>Version 1 of the SCALES board is for development only. Future versions of the board as we develop for flight will include the power and watchdog system on the same board as the flight computer. The development boards for each of these subsystems will be isolated for testing before combining them into one board for flight.</p> <p>Most of this design is based on the dev kit schematics and Hardware Manual, available from PhyTec upon request. This link to the dev kit should supply the necessary supporting documentation used for this design.</p>"},{"location":"imx_carrier_board/#elements-of-the-scales-board","title":"Elements of the SCALES Board","text":"<p>The main elements of the dev kit that are used in the SCALES board are:</p> <ul> <li>Micro USB UART Debug port</li> <li>2 Ethernet ports</li> <li>Micro SD Card Reader</li> </ul> <p>Elements of the dev kit that will be altered significantly for the SCALES board:</p> <ul> <li>Power input and distribution</li> <li>SPI</li> <li>UART</li> <li>I2C</li> </ul>"},{"location":"imx_carrier_board/#schematic-design","title":"Schematic Design","text":"<p>The schematic is organized into heirarchical pages to make the page cleaner and more concise.</p> <p>The root of the schematic includes the board to board (B2B) connectors that interface the SOM to the SCALES board. The same connectors are used in the dev kit.</p> <p>This page will be organized to show essential connections between blocks as the schematic progresses.</p> <p>This version of the SCALES board for development will use DF11 connectors for power input, SPI, UART, and I2C. Later versions of this board for flight will use Gecko connectors. The DF11 is used to reduce lead times for the initial versions of the board.</p> <p>Important note: all signals from the B2B connectors on the SCALES board begin with \"X_\". The same naming convention is used in the dev kit.</p>"},{"location":"imx_carrier_board/#micro-usb-uart-debug","title":"Micro USB UART Debug","text":"<p>Replicated as much of the dev kit design as possible. Main changes are:</p> <ul> <li>MBR0520L is no longer manufactured. using MBR0520LT</li> <li>There is a dip switch and a multiplexor that allow for FTDI to be enabled. The dip switch and multiplexor were removed. (they might be brought back later as we continue to develop UART)</li> </ul>"},{"location":"imx_carrier_board/#ethernet","title":"Ethernet","text":"<p>The i.MX 8X SOM has an onboard ethernet transciever for ETH0, but not ETH1. Any carrier board connected to the SOM is required to implement a transciever for ETH1. The design for this transciever and the supporting ethernet female connector plugs were directly pulled from the dev kit schematic, with the only changes being specific part numbers for components and connectors. The functionality is the same.</p>"},{"location":"imx_carrier_board/#micro-sd-card-reader","title":"Micro SD Card Reader","text":"<p>Everything in the SCALES board is the same as the dev kit except:</p> <ul> <li>No part # for dip switch selected yet</li> <li>Different SD card reader part # used. The one use in the dev kit was not available from JLC PCB.</li> <li>Removed Enable_WIFI switch. This signal is pulled low elsewhere for the multiplexor to still work and we do not need WiFi on the SCALES board, so the functionality was removed.</li> </ul> <p>The multiplexor and switches allow you to switch between NAND flash/boot and SD flash/boot. You cannot use SD at the same time as WiFi. Since we will not be using WiFi, this will not be an issue, but the Enable_WIFI signal still needs to be pulled low for the multiplexor to work for switching between SD and NAND.</p>"},{"location":"imx_carrier_board/#power-input-and-distribution","title":"Power Input and Distribution","text":"<p>The dev kit used a 12V input. The SOM only requires a 3.3V input at 2A, so we will be using a 3.3V input for the SCALES board.</p> <p>The dev kit also gets input power from a barrel jack wall plug. The SCALES board (version 1 development) will be getting input from a DF11 2x8 pin connector through a tabletop power supply.</p> <p>The DF11 power connector used in the SCALES board will also be able to get input power from the SCALES Power Distribution board. Pinouts are still being discussed across boards to maintain consistency.</p> <p>The power input and distribution system of the imx SCALES board is still in development. Trying to figure out how the voltage rails will translate from the dev kit without the 12V input.</p> <p>The i.MX 8X SOM generates 3.3V and 1.8V voltage rails, but the dev kit does not use them. Not sure if SCALES should just use the rails or generate new rails.</p> <p>The dev kit also has a 5V rail, but all the components that use the 5V rail will not be used in SCALES, so it will most likely be omitted. </p>"},{"location":"imx_carrier_board/#spi","title":"SPI","text":"<p>There are expansion header pins on the last page of the dev kit schematic that allow connection to the SPI pins not in use elsewhere on the board. These signals will be connected to the DF11 for use on the SCALES board.</p>"},{"location":"imx_carrier_board/#uart","title":"UART","text":"<p>The UART on the i.MX 8X dev kit is accessible through header pins, RS232, and the Debug USB. We already covered the Debug USB, so figuring out how to use the signals from the header pins and the RS232 for the DF11 is the next step for the SCALES board. Still in progress.</p>"},{"location":"imx_carrier_board/#i2c","title":"I2C","text":"<p>I2C on the dev kit seems pretty straightforward, all that needs to be done is confirm the pinouts for the DF11 with the peripheral board to make sure that everything lines up correctly across both boards for continuity in the design of the system.</p>"},{"location":"imx_yocto_bsp/","title":"i.MX 8X Yocto BSP Development and Usage","text":"<p>Trying to get Yocto Linux BSP working on Ubuntu 22.04 host machine. Work in progress. Come back later!</p>"},{"location":"power_system/","title":"SCALES Power Distribution System Development","text":""},{"location":"power_system/#quick-links","title":"Quick Links:","text":"<ul> <li>Find parts from major distributors: https://octopart.com/ By Luca Lanzillotta</li> </ul>"},{"location":"power_system/#requirements","title":"Requirements:","text":"<p>Supply Power to sub-components on SCALES Carrier Board</p>"},{"location":"power_system/#components-to-be-used","title":"Components to be used:","text":"<p>Components to be used are still being finalized, but they are based on the following SCALES Component Selection List. - Flight Computer: IMX8/VOXL2   - IMX8:        - 3.3V / 2A (Inrush Max) - Power (Max) = 3.63W (based on datasheet)   - VOXL2:        - 12V / 6A (Inrush Max) - Power (Max) = 7W (based on Janelle's testing; check datasheet for idle values)</p> <ul> <li>Edge Computer: Nvidia Jetson AGX Orin</li> <li>End-user must have access to peak power, so they can switch between performance modes.</li> <li> <p>AGR Orin: </p> <ul> <li>20V / 3.75A (MAX) - Power (Max) = 75W (based on max current/voltage ratings)</li> </ul> </li> <li> <p>FPGA System: AMD Artix 7 XC7A200T SOM</p> <ul> <li>5V / 2A (MAX) - Power (Max) = 10W (based on datasheet and max utilization data)</li> </ul> </li> </ul>"},{"location":"power_system/#standardize-power-input","title":"Standardize Power Input","text":"<ul> <li>28V power supply/battery input</li> <li>Based on information compiled above (Does this include system peripherals?):<ul> <li>OBC: 3.3V @ 2A Max (IMX8) / 12V @ 6A Max (VOXL2)</li> <li>EC: 20V @ 3.75A Max (Jetson AGX)</li> <li>FPGA: 5V @ 2A Max (Artix 7 SOM)</li> </ul> </li> </ul>"},{"location":"power_system/#block-diagramsbasic-design-ideas","title":"Block Diagrams/Basic Design Ideas:","text":""},{"location":"power_system/#13025","title":"(1/30/25)","text":"<ul> <li>Basic Block Diagram of EPS board for SCALES Components</li> <li>Requirements: (Using Janelles Power Board Block Diagram for reference)<ul> <li>Microcontroller (Ex: STM32F091)<ul> <li>Checks Watchdog Timer</li> <li>Measures current and voltage outputs</li> <li>Utilizes CAN/I2C to relay current/voltage info to OBC</li> </ul> </li> <li>External Voltage in connector<ul> <li>start thinking about types of connectors that can handle high current input @ 24/28V inputs that are standard in aerospace/cubesat applications</li> </ul> </li> <li>Analog to Digital converters <ul> <li>Used to measure voltage/current values and translate them to GPIO inputs for the MCU</li> </ul> </li> <li>Voltage Channel Buck Converters/Switching regulators</li> <li>RBF System<ul> <li>Use relay to bypass high current/ MOSFET/FET?</li> </ul> </li> <li>Temperature Sensors for Buck/Switching Regulators</li> </ul> </li> </ul>"},{"location":"power_system/#2325","title":"(2/3/25)","text":"<ul> <li>1st Block Diagram:  </li> <li> <p>Comments from Zach:        No need for MCU, Watchdog takes care of system stability based on timing pings       Watchdog should be powered straight from the 28v stepped down to 5v/3v3       Does Each voltage line needs to have voltage/current sensors? This is because it may be completely redundant, theres no point in adding a sensor that depends on the OBC to be running and even if what would it be doing?       Stick to a simple design, we need to make sure the watchdog can operate independently from the 3 subsystems, just needs a switching regulator to function, then the pinged input from the OBC will stop the system from resetting.       Because the watchdog will be what triggers the power cycle, we need to add some sort of system relay that triggers if a ping is not recieved.</p> </li> <li> <p>2nd Block Diagram: </p> </li> <li> <p>Requirements: (More simple design, almost purely analog)</p> <ul> <li>28V V+/GND Connector</li> <li>Relay/Switch system to be triggered by Watchdog (Normally Closed, Watchdog RST command triggers Open Switch)</li> <li>Switching Regulators<ul> <li>28v -&gt; 20v (up to 8A) (Jetson)</li> <li>28v -&gt; 24v/22v (Watchdog)</li> <li>28V -&gt; 12v (OBC VOXL2/IMX8)</li> <li>28v -&gt; 5v (FPGA Artix 7)</li> </ul> </li> <li>Watchdog System<ul> <li>Based on the TLV1704-SEP (Voltage input rated up to 24v)</li> <li>No idea how it works but its what we will be using, schematic is complicated, linked above</li> </ul> </li> </ul> </li> <li> <p>Comments from Zach: Simple, makes sense</p> </li> <li>Comments from Michael:         - Watchdog system for each logic system, to trigger each individual line rather than the whole system         - To trigger the reset, dont use relays, find some sort of solid state system          - Power sequencing to turn on each section individually, inrush current will be too high if we turn them on all at once          - delay timer to sequence each section</li> </ul>"},{"location":"power_system/#research-notes","title":"Research Notes:","text":""},{"location":"power_system/#12825","title":"(1/28/25)","text":"<ul> <li>Figure out each of the maximum power requirements for each of the components</li> <li>Start looking into how power distribution systems work for different power levels</li> <li>Resources: <ul> <li>TI Application Notes</li> <li>Basics Power MUX</li> <li>SmallSat Power Systems - NASA</li> </ul> </li> </ul>"},{"location":"power_system/#12925","title":"(1/29/25)","text":"<ul> <li>Examples of existing EPS distribution boards</li> <li>IBEOS 150-Watt SmallSat EPS</li> <li>Pumpkin EPSM1</li> <li>GOMSPACE NanoPower P31u</li> <li>ISISPACE ICEPS2</li> <li> <p>Skylabs NanoEPS 158W</p> <ul> <li>Common Components in Power Boards   This list of components for the power board is based on information gathered from the various power systems above<ul> <li>MCU:<ul> <li>Power regulation monitoring</li> <li>voltage and current measuring</li> <li>Fault detection and protection</li> <li>protects against shorts, overcurrent, brownouts and undervolting situations</li> <li>can send system reset commands</li> <li>OBC communication for power telemetry</li> <li>integrate with IMX8/VOXL2</li> </ul> </li> <li>Temperature sensors:<ul> <li>Used to monitor connector/converter temps in case of high current cases</li> <li>Some smallsat EPS use thermistors as a way to easily measure temperature, may be innacurate, or simple enough</li> </ul> </li> <li>Watchdog:<ul> <li>sends regular intervals to main components to check that they are operating correctly, IIRC only the jetson will have this</li> </ul> </li> <li>Switching Regulator/(DC/DC) Buck Converter:     -Steps down voltage with minimal loss to respective subsystem (Uses capacitors, inductors and transistors to step down voltages using switching frequencies)<ul> <li>28V -&gt; 3v3/5v/12v @high current input/output</li> </ul> </li> <li>RBF Pin/Kill Switch/Reset Switch:<ul> <li>Some</li> </ul> </li> <li>Fuse: (probably not the best to use because if it blows, the whole system is inoperable until it comes back down)<ul> <li>Last bastion of defense in case of a current surge, protecting all components from frying (not likely to be used)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"power_system/#2325-21025","title":"(2/3/25) - (2/10/25)","text":"<ul> <li>EPS:</li> <li>28V Power Input<ul> <li>Connectors:<ul> <li></li> </ul> </li> </ul> </li> <li> <p>Load Switches INFO</p> <ul> <li>Load switches come AFTER switch regulators<ul> <li>Load Switch<ul> <li>TILM73100 </li> <li>Going with ths one for now because of the high current and voltage rating, has integrated current sensing, over and undervoltage protection, and an enable pin. Also has an analog current sensor.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Switching regulator Vicor PI3740-00 (this is probably insanely fucking overkill, but better safe than sorry)</p> <ul> <li>Using one for each subsystem, they are about 12 dollars each, and have very high efficiency ratings, they also have the majority of components already integrated.<ul> <li>Datasheet has recommended capacitors for specific voltage ranges as well as calculation sheet for inductor selection</li> </ul> </li> <li>28v -&gt; 5v (Watchdogs)</li> <li>28v -&gt; 20v (Jetson)</li> <li>28v -&gt; 12v (OBC)</li> <li>28v -&gt; 5v (FPGA)</li> </ul> </li> <li>Voltage/Current monitor<ul> <li>INA230      -36V, Voltage and Power sensor, I2C communication</li> </ul> </li> <li>Watchdog(s)<ul> <li>Need 3, one for Jetson, OBC, FPGA<ul> <li>Use Proves implementation available here</li> </ul> </li> </ul> </li> <li>Watchdog for each voltage level instead of the full system</li> </ul>"},{"location":"power_system/#21125","title":"(2/11/25)","text":"<ul> <li>Notes on Rev A from michael:</li> <li>Switching Regulator: Vicor PI3740 is not in stock, find another one, stick to TI or Analog devices</li> <li>Add a GPIO pin to toggle the enable pin on each regulator, if its needed to reset power output</li> <li>Make sure all capacitors are ceramic, electrolytic caps can explode in space</li> <li>Move to Rev B:</li> <li> <p>Implement the following:        ## Switching regulators ##             - [LT8638SEV] (https://www.mouser.com/ProductDetail/Analog-Devices/LT8638SEVPBF?qs=sGAEpiMZZMsMIqGZiACxIZbomz1DP27AbMqUs%252Bj26yi9VZ8WhNpLhw%3D%3D)             (2.8V to 42V 10A/12A) Both should be the same             - Left off on implementing footprint and symbol will implement design wednesday             - Daisy Chain CLK implementation:                The goal with this is to put each regulator (4) slightly out of phase with the others but all at the same switching frequency, this is to reduce input current ripple on each regulator                PHMODE sets the phase angle output for the clock cycle, so the idea would be to set the first one to a PHMODE of 0, the next for a PHMODE of 90deg, then the next 180, and then 270 so well have 4 out of phase.                - Pins:                    - PHMODE: Tie to ground for single phase operation                    - BIAS: Because output voltage is from 3.3v to 25v, datasheet says to tie it to Vout                    - INTVcc: Internal 3.4V regulator bypass pin. Use a 1uf ESR capacitor from here to ground CLOSE to the ICEPS2                      - 1uF capacitor                    - BST: Used to provide a drive voltage, higher than the input voltage, supplies current to the topside power switch, us a 0.1uF boost capacitor                      - 0.1uF capacitor                    - SW: Outputs of the internal power switches. Tie them together and connect them to the inductor. For the PCB keep the nodes small and close together.                      - Confirm inductor value                    - GND: Place the gnd terminal of the input capacitor as close to the GND pins as possible. Try to use pins 29 and 32 for best thermal performance although they may be left disconnected.                    - Vin: VIN pin supply current to the LT8638S internal circuitry and to the topside switch. To be tied together and be locally bypassed by a 4.7uF capacitor.                      - 4.7uf capacitor                      - Place the capacitor + side as close to the VIN pins, and the - side as close as possible to the GND pins                   - EN/UV: Enable pin for the IC, you can use a voltage divider configuration from Vin to set a threshold voltage to program the IC to turn off if the voltage drops below this level. I will not be using this.                   - RT: A resistor is tied between RT and ground to set the switching frequency                      - Confirm switching frequency for output voltage and current                   - CLKOUT: Output clock signal for PolyPhase Operation, in forced continuous, spread spectrum, and synchronization mode it outputs a 50% duty cycle square wave of the switching frequency. If in burst mode operation, the CLKOUT pin. If not use, let it float. I  wont be using this pin. NC                   - Sync/Mode: Has four operating modes:                      - Burst Mode: Tie to ground for this mode.                      - Forced Continuous Mode, fast transient response and full frequency load over a wide load range, Float pin for this mode.                      - Forced Continuous Mode with Spread Spectrum, allows for FCM but with a small modulation of the switching frequency to reduce EMI, if desired tie to INTVcc                      - Synchronization Mode, drive it with a clock source to an external frequency, during the sync it will behave in forced continuous mode                   - PG: Power good pin, remains low until the FB pin is within +-7.75% of the final regulation voltage. PG is valid when Vin is above 2.8V                   - SS: Output tracking and a soft start pin, allows for regulation of the output voltage ramp rate. Documentation has a function that relates the input voltage to the pin to the rate at which the output voltage can increase by. I will not be using this as a load switch will take care of this. In order to disable this, set SS to higher than 1v, or may be left floating.                   - FB: Feedback pin that sets the output voltage according to a provided formula in the data sheet                   - Vc: Internal error amplifier, used to help stability in the output voltage, recommended by data sheet is a 10kohm resistor with a 1nF cap to ground.                             - Jetson Config:                   - Enable FCM:                      - Leave Sync/Mode pin floating                   - FB Resistor Network:                      - Program the output voltage with a resistor divider, Jetson requires 20V.                      - Formula: R1 = R2((Vout/.6v)-1)                      - Calculated Values: R1 = 100kOhm, R2 = 3kOhm, Check calculations sheet to check.                   - RT Resistor Selection:                      - Resistor value that sets the switching frequency based on the following formula                      - RT = (44.8/fsw) -5.9, RT is in Kohms                      - Settled on 400Khz so RT about 105KOhms                      - Calculations done on sheet on my ipad, will link here later                   - Inductor Calculation and Selection:                      - Requires about 4 different calculations including the frequency selection.                      - Concluded with L &gt;= 6uH with Irms &gt;= 15A for safe operation                   - Sync Pin has to be tied to external clock with phase shift (4 total so 0, 90, 180, 270)                - OBC Config:                   - Enable FCM:                      - Leave Sync/Mode pin floating                   - FB Resistor Network:                      - Program the output voltage with a resistor divider, OBC requires 12V.                      - Formula: R1 = R2((Vout/.6v)-1)                      - Calculated Values: R1 = 95kOhm, R2 = 5kOhm, Check calculations sheet to check.                   - RT Resistor Selection:                      - Resistor value that sets the switching frequency based on the following formula                      - RT = (44.8/fsw) -5.9, RT is in Kohms                      - Settled on 400Khz so RT about 105KOhms                      - Calculations done on sheet on my ipad, will link here later                   - Inductor Calculation and Selection:                      - Requires about 4 different calculations including the frequency selection.                      - Concluded with L &gt;= 6uH with Irms &gt;= 13A for safe operation, with L calculation settled on 6.4uH                   - Sync Pin has to be tied to external clock with phase shift (4 total so 0, 90, 180, 270)                - FPGA Config:                   - Enable FCM:                      - Leave Sync/Mode pin floating                   - FB Resistor Network:                      - Program the output voltage with a resistor divider, FPGA requires 5V.                      - Formula: R1 = R2((Vout/.6v)-1)                      - Calculated Values: R1 =22kOhm, R2 = 3kOhm, Check calculations sheet to check.                   - RT Resistor Selection:                      - Resistor value that sets the switching frequency based on the following formula                      - RT = (44.8/fsw) -5.9, RT is in Kohms                      - Settled on 400Khz so RT about 105KOhms                      - Calculations done on sheet on my ipad, will link here later                   - Inductor Calculation and Selection:                      - Requires about 4 different calculations including the frequency selection.                      - Concluded L calculation settled on 2.9uH so 3uH should work fine                   - Sync Pin has to be tied to external clock with phase shift (4 total so 0, 90, 180, 270)                - +5v Peripheral Config:                   - Enable FCM:                      - Leave Sync/Mode pin floating                   - FB Resistor Network:                      - Program the output voltage with a resistor divider, FPGA requires 5V.                      - Formula: R1 = R2((Vout/.6v)-1)                      - Calculated Values: R1 =22kOhm, R2 = 3kOhm, Check calculations sheet to check.                   - RT Resistor Selection:                      - Resistor value that sets the switching frequency based on the following formula                      - RT = (44.8/fsw) -5.9, RT is in Kohms                      - Settled on 400Khz so RT about 105KOhms                      - Calculations done on sheet on my ipad, will link here later                   - Inductor Calculation and Selection:                      - Requires about 4 different calculations including the frequency selection.                      - Concluded L calculation settled on 2.9uH so 3uH should work fine                   - Sync Pin has to be tied to external clock with phase shift (4 total so 0, 90, 180, 270)       ## Load Switch ##          - [LTC4375] (https://www.analog.com/media/en/technical-documentation/data-sheets/LTC4365.pdf)             - Requires: [SISB46DN-T1-GE3] (https://www.vishay.com/docs/76655/sisb46dn.pdf)             - ^ Dual channel 40v MOSFET             - Has an active high pin that when triggered low sets the current output to be very low, labeled SHDN pin             - Has overvoltage and undervoltage pins that set safety levels for OV and UV which can be configured by voltage dividers. Will configure +-2V for each component. More on this below             - SHDN Config -&gt; Tied to Watchdog output, triggered high when everything is working correctly and when set low the load switch disables the load             - No utilizing fault output</p> <p>## Clock ##      - [LTC6902] (https://www.analog.com/en/products/ltc6902.html)          - Allows for setting phase outputs as well as resistor programmable frequency timings            - Set Phase Mode: 4 Phase connect PH to V+, set N to floating which is 10 due to frequency range of 5Khz &lt;= 400Khz &lt;= 500Khz            - Since SSFM (Spread Spectrum Frequency Modulation)            - Review calculations page in EPS-&gt; Calculations folder to verify with datasheet instructions.            - Phases set:               - 5v Perif -&gt; 0deg               - FGPA -&gt; 90 deg               - OBC -&gt; 180 deg               - Jetson -&gt; 270 deg   ## Current/Voltage Sensors ##      - INA230      - Shunt resistors have really low resistance to allow for high currents on each line, Vbus is also used to measure voltage. Bear in mind each shunt resistor should have a   relatively high power dissipation rating to prevent it from burning up.    - Notes for RevB:   - Add decoupling capacitors to input voltage lines   To Do (2/19/25):    - Add soft start capacitors to every switch regulator so that they delay long enough for the clock to be powered first   - Each is given a 25nF Soft Start capacitor to take 10ms to fully turn on the regulator, this allows the clock to be powered first by setting a shorter slew rate time therefore setting them all out of phase before they fully turn on. [DONE]    - Start calculating load switch resistors and capacitor values [DONE]    - Pick and integrate 28v to 5v buck converter for clock [DONE]    - Add decoupling capacitors to input voltage lines [DONE]</p> </li> <li> <p>Notes (2/19/25) </p> <ul> <li>Filter caps added at power input</li> <li>Notes are written for everything, calculations are in the EPC calculations folder. Rev B schematic DONE. </li> <li>Next phase is review with Michael and then ERC cleaning. </li> </ul> <p>=======    ## EPS REV.B Review Notes ## - https://scales-hardware.readthedocs.io/en/latest/meeting_notes/feb_21_25/ - REV C -&gt; Satcat dropped moving to new FPGA board - Make an updated Block diagram to reflect what the schematic is without getting too complicated</p> </li> </ul> <p>### To do 2/25/25    - Rev C: (Make new block diagram)       - Power Input Spec:          - Define power input requirement          - How low is undervoltage?             - Jetson:                - Soft start capability?                - Idle current                - Max operational average current                - Max transient current       - Load Switches: (Need a new selection)          - Go BEFORE switching regulators          - Need current sensing capability          - Add slew rate caps for turn on time       - Switching Regulators:          - Verify Rt sets clock when power drops          - Power on first, then worry about syncing       - Clock: (Need a new selection)          - Switch to a crytal oscillating clock instead of what is current chosen</p> <p>## Week of 3/3 ##        - Goals:          - Complete Block Diagram of Rev C [DONE]          (LINK HERE)[https://drive.google.com/file/d/1UQ95z8zSc4xQTobpHLgdMU17UKOtdfAZ/view?usp=sharing]          - Finalize Rev C Requirements:             - Interface requirements for OBC/Jetson/Peripheral Board                - Gecko Connectors?             - Power: The EPS system will supply 4 switching regulators with adecuate voltage and current:             - Load Switch Configuration:                 - Each subsystem has a load switch with a rst toggle, all are handled by the OBC, as well as the watch dog timer. Meaning both can be pulled down depending on the state.                - Watchdog system has a load switch which in the case of a watch dog failure, indicated by the I/V sensor can reset the timing for ensured redundancy             - Switching Regulator Configuration:                - Jetson: 28v to 20v @ 6A MAX                   - Start in sync with OBC                - OBC: 28v to 5v @ 3A MAX                   - Start in sync with Jetson                - Perif: 28v to 5v @ 2A Max                   - Start Early to boot up smaller components                - Watchdogs and Clock: Powered by OBC, boots first                Startup sequence:                OBS powers on first due to shortest SS. Clock turns on, sets frequency and phase, then it pulls the Enable pins on the load switches high and then the Jetson and Perif Load switch turn on. Then I2c Sensors are powered on for each and data is starting to be read for each subsystem.</p> <pre><code>     ## Modifications for this to happen ## \n        - Set SS capacitor for OBC/Jetson/Perif Load Switch to cause slightly longer turn on time compared to Clock and WDs\n        - WD intial boot capacitor must be set for longer time to allow for proper system boot sequence\n        - Software on OBC should allow for when the WDs are to be reset, to pull its own RST pin for the load switch high, so on reset the watch dogs do not false trigger the reset on the OBC load switch\n        - Need to implement I2C Program to monitor incoming I/V sensor signals for each subsystem\n\n     - Finalize Rev C Component Selection:\n        - Edge Computer: Jetson Orin AGX (20V/6A Out)\n        - Flight Computer: IMX8 (Have a 5v/3A Out)\n        - Peripheral Board: N/A (Have a 5v/2A Out)\n\n        - Capacitors: SMD Ceramics\n        - Resistors: SMD Wire Wounds\n        - Inductors: SMD No-Air Ceramic\n\n        - Load Switche(s): [LTC4365](https://www.analog.com/media/en/technical-documentation/data-sheets/LTC4365.pdf)\n           - Require: [SISB46DN-T1-GE3](https://www.vishay.com/docs/76655/sisb46dn.pdf)\n        - Switching Regulator(s): [LT8638SEV#PBF](https://www.mouser.com/ProductDetail/Analog-Devices/LT8638SEVPBF?qs=sGAEpiMZZMsMIqGZiACxIZbomz1DP27AbMqUs%252Bj26yi9VZ8WhNpLhw%3D%3D)\n        - Clock: [LTC 6902](https://www.analog.com/media/en/technical-documentation/data-sheets/6902f.pdf) (Use SSFM)\n        - I/V Sensor(s): [INA230](https://www.ti.com/lit/ds/symlink/ina230.pdf?ts=1739195723292)\n\n\n     - Complete Rev C Schematic:\n\n     - Begin EPS Board Layout:\n        PCB Notes:\n           -JLC PCB has specific requirements for manufacturing be sure to check everything needed to make sure it is correct.\n           Check Here[https://jlcpcb.com/capabilities/pcb-capabilities]\n\n           -Each component has specific design constraints so make sure that the component is following its pcb layout design spec\n\n           -How should I go about routing?\n              - So far ive just been connecting nets together and when I cant make a connection from the top plane im just using vias to connect things together through the planes. Not entirely sure if this is how it should be done but it seems to be working so far.\n              - Latest problem is the SIS mosfet which the pads wont let me do connections to easily\n\n        - Rev C Dev Board Notes 3/26/25\n           - Ran into some bullshit github issues to be honest I have no fucking clue what the problem is but thankfully I was able to remove the problem by nuking my branch, and pulling from main again and then merging it to main. \n           - Redid layout for all the components, im happy with what i have right now. Going to go over this and start routing from the beginning. What I will try is doing the jetson subsystem and then trying to copy the same tracks and use multichannel\n           - I also removed the XNOR configuration because it doesnt make sense to add it. Sure it can be useful but on a boot sequence its useless because it can throw me into a infinite boot loop essentially a race condition because its trying to turn on faster than it is triggered off by the first system to power on\n\n     ## Week of 3/31/25 ##\n        -REV C Dev Board To Do's 3/31/25\n           - Gecko Connectors swap to DF11-16DP-2DSA(08) Connector [DONE]\n              - Make sure the footprint has the through holes\n           - Add meme to the front of the board\n           - Add schematic layout to the back of the board for dev purposes\n           - Test WD kit Michael made on the scope, test with different voltage ranges\n\n        -REV C Dev Board Revision Suggestions from Andrew Greenberg (4/1/25)\n           Main Concerns:\n           - Stop working on layout so you dont waste your time [DONE]\n           - Rename +28V as Vbatt and display voltage ranges (Vbatt = [24.0, 28.8, 33.6]) [DONE]\n              -Reconfigure the UV and OV numbers to allow for this voltage range [DONE]\n                 - Modify in the calculations page (be sure to note the numbers) \n           - 100nF caps on +28V inputs can be removed due to 10uF [DONE]\n           - Ensure the capacitors are +75v rated so they dont explode at the input side [DONE]\n              -Must be ceramic [DONE]\n              -Must be around double of what the peak input voltage is for safe margins [DONE]\n\n           SISB46DN: [DONE]\n              -Replace symbol with 2 MOSFETS so that the end user can understand what the schematic actually represents\n           INA230:\n              -Calculate proper resistor values for the INA230 voltage and current detection [DONE] (In rev c calcs last page)\n              -Remove 4.7k resistors on the INA230 side, you want to include them on the host side, be sure to add these notes in the schematic [DONE]\n\n           -Physical Design Revision Notes:\n              -For each component go to its manufacturing page and make note of all the component types that are used for the individual designs, this means that the devices that are used for each are recommended by the manufacturer in the evaluation board.\n\n              -Replace the footprints for all the inductors to ensure they have the proper current ratings and also have proper spacing for additions to it on the board.\n\n              Manufacturer recommended components around subsystem comcponents: [DONE]\n                 LTC4365:\n                       -No hard restrictions on component selection for those that will go around it\n                       -Worth adding test points to the UV/OV side to see the values it should trip at\n                 LS8638SEV: \n                       -Use +50v rated ceramic caps, 3225 metric packages\n                       -Use this kind of inductor: https://www.coilcraft.com/en-us/products/power/shielded-inductors/molded-inductor/xel/xel6030/?srsltid=AfmBOoqxe6hS-AVIr3woqGFRZjt3QaXyQi86MwGE0zvqKz2AENsjz4RA\n                       this is the one referenced in the evaluation board. Having trouble finding the footprint for the right sizing\n                 INA230: No specifics on what caps or resistors to use, go with ceramic caps and carbon/ceramic resistors as usual\n                 LTC6902:\n                       -No strict requirements on what type of components are used with it\n\n            Watchdogs:\n              -Probe C19 and C20 as well as the 100k resistor.\n              -Worth doing circuit analysis on to make out mathematically what is going on in the circuit\n\n           Extra Stuff:\n              -For the OBC SDA/SCL, we need to include an i2c buffer to ensure proper signaling, for this we can use the    LTC4300A\n</code></pre>"},{"location":"power_system/#scales-eps-rev-c-design-development","title":"SCALES EPS REV C Design Development","text":"<ul> <li>By Luca Lanzillotta</li> <li>4/15/2025</li> <li>4/16/2025</li> </ul>"},{"location":"power_system/#abstract","title":"Abstract ##","text":"<ul> <li>The SCALES EPS Board is a power distribution board designed with the intention of powering a flight computer, a machine learning edge computer, and a peripheral system for onboard diagnostics and user defined sensors to interface with both the flight computer and the edge computer. Each subsystem is equipped with an error mitigation feature known as a watchdog, which is pet by each corresponding subsystem and serves as a reset point for each subsystem. The flight computer has access to power diagnostics for each subsystem and can be is software programmable of its direct control of each subsystems operation mode.</li> </ul> <p>### Component Selection ###    Primary Components: </p> <ul> <li> <p>IV Sensor:     INA230</p> </li> <li> <p>Switching Regulator:     LT8638SEV</p> </li> <li> <p>Load Switch:    LTC4365</p> </li> <li> <p>Dual-Gate Mosfet:     SISB46DN-T1-GE3</p> </li> <li> <p>Clock:     LTC 6902</p> </li> <li> <p>Power Connector:     XT-60</p> </li> <li> <p>Watchdog Comparator:     TLV-1704SEV</p> </li> </ul> <p>Secondary Components:</p> <p>Resistors:    - (0603):       - Load Switch (UV/OV, SHDN Pull Down)       - Switching Regulator (Vc, Rt, Bias, Fb)       - Clock (Mode set, Rt set)       - Watchdog (WDT-Vin, every block within the system)    - (2512):       - IV Sensor Shunt (IN+ to IN-)</p> <p>Capacitors:</p> <ul> <li>(1210) +75V:<ul> <li>Input Power Connector (Filter caps)</li> <li>Load Switch Output (Filter caps)</li> <li>Switching regulator (BST to SW, BIAS to FB, SW to INA IN+)</li> </ul> </li> </ul> <p>Inductors:</p> <ul> <li>Per recommendation of the LT8638SEV evaluation board design the recommended inductors are the following<ul> <li>XEL6030</li> <li>Switching regulator (BST to SW)</li> <li>Rated from 0v to 80v</li> <li>AEC-200 rated (automotive standard)</li> <li>IRMS ratings are more than reasonable based on REV C calculations requirements</li> <li>Refer to layout requirements in the datasheet</li> </ul> </li> </ul> <p>### Requirements ###</p> <ul> <li> <p>Power: (XT-60 Connector)</p> <ul> <li>28V/12A Max Input</li> <li>3 Subsystems, OBC, Edge Computer, Peripheral</li> <li>Existing calculations for inductors and input power are overspecked</li> </ul> </li> <li> <p>Load Switches: (LTC4365)</p> <ul> <li>Dual Gate Mosfet (SISB46DN-T1-GE3) is utilized to pass the output based on the inputs of the load switch IC</li> <li>SHDN feature is held by the WD and/or the flight computer depending on the subsystem</li> <li>UV/OV thresholds are adapted to the input ratings set by LiPO operating ranges, each subsystem has a calculation in the REV C calculations in this subfolder.</li> <li>Soft Start capacitors for each subsystem mitigate current spikes at the input side when initializing, they also serve as start up delays</li> </ul> </li> <li> <p>Clock: (LTC6902)</p> <ul> <li>Set to 400khz based on average performance metrics for the switching regulator(s)</li> <li>Using SSFM to reduce system wide noise of a specific signal</li> <li>3 Phases used to seperate switching frequency timing across each regulator</li> </ul> </li> <li> <p>Switching Regulators: (LT8638SEV)</p> <ul> <li>Switching frequency set by clock, phase set by clock</li> <li>In the case of clock failure, a frequency setting resistor on the switching regulator will maintain a constant switching frequencyIn the case of clock failure, a frequency setting resistor on the switching regulator will maintain a constant switching frequency</li> </ul> </li> <li> <p>Watchdog(s): (TLV1704SEV)</p> <ul> <li>Watchdogs for each subsystem</li> <li>OBC controls which subsystem is on, OBC is always on</li> <li>Watchdogs are PET every ~30s by their respective subsystem</li> <li>Utilizing an adapted version of the OreSAT design provided by Andrew Greenberg Design HERE</li> <li>NOTE: The current watchdog implementation is currently not operating as expected, refer to testing notes.md in this folder for more information on progress    </li> </ul> </li> </ul>"},{"location":"power_system/#rev-c-block-diagram","title":"Rev. C Block Diagram","text":""},{"location":"power_system/#design-revision-notes","title":"Design Revision Notes","text":"<ul> <li> <p>Use the JLCPCB Component stock checker plugin </p> </li> <li> <p>Fix Dual Gate Mosfet input and output pins Vin and Vout are references for the Load Switch [FIXED]</p> </li> <li> <p>Add a resistor to the WD_Toggle so when the WD pulls low it doesnt short the GPIO pin on the subsystem GPIO [FIXED]</p> </li> <li> <p>Set all caps to be +75v rated [FIXED]</p> </li> <li> <p>Set the shunt resistor to 10mohms [FIXED]</p> </li> </ul>"},{"location":"satcat_board_design/","title":"SatCat Custom Carrier Board Design","text":"<p>This document shows the progress of development of the carrier board for SatCat5. The base of the design is based on Aerospace Corp's SatCat5 open source ethernet switcher. Their GitHub includes a prototype design featuring the AC701 Evaluation Board for the Artix 7 FPGA chip. For the purposes of SCALES, an evaluation board like that is not something we would want in our design, so we are using an SOM of the Artix 7 instead.</p> <p>The idea is to take the important signals from SatCat's prototype using the AC701 and modify it to work with the SOM we would use in SCALES. This presents a problem for us, since the AC701 uses a different version of the Artix 7 than the SOM, so the signals don't match up to the same pins on the Artix 7 chip.</p> <p>We have currently decided to pause development on SatCat for SCALES, as much of the open source design available through Aerospace Corp's GitHub lacks enough detail for s to fully move forward. We have experienced too many barriers in this design to justify the amount of work needed to verify the design.</p>"},{"location":"satcat_board_design/#mapping-the-signals","title":"Mapping the Signals","text":"<p>The AC701 Evaulation Board used in the SatCat prototype uses the xc7a200tfbg676 version of the Artix 7 200t FPGA. The SOM that will be used in SCALES uses the xc7a200tfbg484 version of the Artix 7 200t FPGA.</p> <p>Resources:</p> <ul> <li>SatCat prototype PCB design</li> <li>AMD Artix 7 FPGA AC701 Evaluation Kit used on SatCat</li> <li>AC7200 FPGA SOM used on SCALES</li> <li>Pin definitions for the FGB676 on the AC701</li> <li>Pin definitions for the FBG484 on the SOM</li> <li>AMD 7 Series FPGA Packaging and Pinout</li> </ul> <p>Steps: </p> <ol> <li>Look at the SatCat proto PCB schematic. The FPC connector on page 1 is what connects their proto PCB to the AC701 evaluation board. In a spreadsheet, copy the names of each signal bank letter and pin number used in the FMC connector for SatCat.</li> <li> <p>Find the datasheet/user's guide for the AC701 evaluation board. Navigate to the \"FPGA Mezzanine Card Interface\" on page 58. There is a table in this section listing the schematic net names for the FMC connector. The first column is the bank letter and pin number (ex. C10) of the FPC connector and the last column is the corresponding pin on the FPGA chip (ex. G19) of the AC701 eval board. Add these to the sheet for each SatCat signal.</p> <p></p> <p>FMC pin definitions</p> <p></p> <p>SatCat FMC pin signals</p> </li> <li> <p>Take the Pin definitions for the FGB676 on the AC701 and add them to the spreadsheet in a different tab. Do the same for the Pin definitions for the FBG484 on the SOM. It may also help to combine these lists in their own tab to make cross-referencing easier.  The spreadsheet used in SCALES is organized as follows:</p> <ul> <li>signals - main sheet to show and compare the signals between the AC701 eval board and the SCALES SOM</li> <li>chips - shows the pin definitions for each chip variation to cross-reference in the signals sheet.</li> <li>xc7a200tfbg484pkg - pin definitions of the SOM chip pulled from the txt file. for reference only.</li> <li>xc7a200tfbg676pkg - pin definition of the eval board chip pulled from the txt file. for reference only.</li> </ul> </li> <li> <p>In the chips tab of the sheet, ctrl+f for the FMC pin name (ex. G19) and find the corresponding signal name for the FBG676 chip used on SatCat. Make sure to select \u201cMatch entire cell contents\u201d and that you are searching the Value, not the Formulas in the Find and Replace options. Copy the signal name to the main sheet and repeat for all signals on the FMC.</p> <p></p> <p>Find and Replace example</p> <p></p> <p>Signal Matching example</p> </li> <li> <p>Now, the same signal on the other chip will not match up to the same pin, so we have to ctrl+f for the signal name of each FMC/SatCat signal in the chips tab of the sheet in the SOM FBG484 column, then copy the pin and signal name name over to the signals sheet.</p> <ul> <li>Disclaimer: the 484 chip does not have a bank 12, but the 676 does. For our purposes, I am replacing the signals used on bank 12 of the 676 FMC chip with the equivalent signals on bank 13 of the 484 SOM chip. I do not currently see an issue with this, but it is something to keep in mind if issues arise later.</li> </ul> <p></p> <p>Find and replace for SOM</p> </li> <li> <p>Once that is done, open the SOM schematic (found in the \"Documentations\" section). Here you will see each bank of the SOM with the FPGA signal name, FPGA pin name, and the SOM signal name listed for each output. Ctrl+F for each FPGA pin on the SOM and copy down the matching SOM output signal name into the spreadsheet. These SOM output signals will be what the board-to-board (B2B) connector uses to communicate with the SCALES custom carrier board.</p> <p></p> <p>Resulting spreadsheet with the SOM signals on the right</p> </li> </ol>"},{"location":"satcat_board_design/#starting-the-schematic","title":"Starting the Schematic","text":"<ol> <li> <p>Download the KiCad library files for the Board to Board Connector on Mouser. Start a new project in KiCad and place four connectors down.</p> </li> <li> <p>The SOM schematic (found in the \"Documentations\" section) page 12 shows the Board to Board (B2B) connectors on the SOM that we will be using. Using that schematic as a reference, match the signals on the connectors to the ones listed in the spreadsheet. Replace the SOM signal name on the schematic with the equivalent SatCat signal name.</p> <p></p> <p>Section from the spreadsheet</p> <p></p> <p>SOM B2B original schematic section</p> <p></p> <p>SCALES SOM B2B modification (same section)</p> </li> </ol>"},{"location":"satcat_board_design/#design-considerations","title":"Design Considerations","text":"<p>We are going to be trying to imitate what Aerospace Corp did with SatCat on Slingshot which was:</p> <ul> <li>4x Gigabit ethernet SGMII</li> <li>up to 16 SPI/UART depending on scale of the Handle bus</li> </ul> <p>Still working on what comes next. To be continued...</p>"},{"location":"scales_demo/","title":"SCALES Demo Development","text":"<p>This demo combines the F Prime Hub Pattern developed by the SCALES team with COTS evaluation boards for the Flight Computer and Edge Computer. The demo aims to accomplish the following:</p> <ul> <li>Test the capability of the split computing architecture</li> <li>Test the capability of using a network ethernet switch in this architecture</li> <li>Test the command and data handling aspects of the Flight Computer</li> <li>Test using the Hub Pattern to have the Flight Computer command the Edge Computer</li> </ul>"},{"location":"scales_demo/#setup","title":"Setup","text":"<p>The i.MX8X Flight Computer evaluation board, Jetson Edge Computer evaluation board, and COTS ethernet camera will be connected through a COTS managed ethernet switch. The i.MX will command the Jetson through the Hub Pattern to take a picture using the Ethernet Camera. The picture will be saved on the Jetson. When completed, the i.MX will command the Jetson through the Hub Pattern to run a computer vision algorithm on the images taken with the camera. The results will be sent to the i.MX.</p>"},{"location":"scales_demo/#process","title":"Process","text":"<p>Using a pre-existing F Prime deployment, we created a new component called RunLucidCamera. The component achieves the following:</p> <ul> <li>GDS command to set up the camera and make sure it is connected</li> <li>GDS command to take a picture and save an image from the ethernet camera</li> </ul> <p>We recycled and modified existing example code from the ethernet camera's SDK. To do this, we needed to integrate the Arena SDK for the ethernet camera into the F Prime deployment. </p>"},{"location":"scales_demo/#arena-sdk-in-f-prime","title":"Arena SDK in F Prime","text":"<p>The Arena SDK was installed from Lucid</p> <ol> <li>Create a <code>Libs</code> folder in the root directory of the project.</li> <li>In <code>scales-software/project.cmake</code> add the <code>Libs</code> folder as a subdirectory.</li> <li>Copy the Arena SDK folders into <code>Libs</code> at <code>scales-software/Libs/ArenaSDK</code></li> <li>Make a CMakeLists.txt files at <code>scales-software/Libs/CMakeLists/txt</code> and add the following: <code>add_fprime_subdirectory(\"${CMAKE_CURRENT_LIST_DIR}/ArenaSDK\")</code></li> <li>Make a new CMakeLists.txt at <code>scales-software/Libs/ArenaSDK/CMakeLists/txt</code> and add the Arena SDK library paths. Currently, the only way this worked was to add the paths to the exact files we wanted. </li> </ol> <pre><code>set(MODULE_NAME Libs_ArenaSDK)\n\nadd_library(${MODULE_NAME} INTERFACE)\ntarget_include_directories(${MODULE_NAME} INTERFACE\n    ${CMAKE_CURRENT_LIST_DIR}/include/Arena\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/CPP/include\n    ${CMAKE_CURRENT_LIST_DIR}/include/Save\n    ${CMAKE_CURRENT_LIST_DIR}/include/GenTL\n    )\n\ntarget_link_libraries(${MODULE_NAME} INTERFACE\n    # Your existing libraries\n    Components_RunLucidCamera\n\n    # Arena SDK libraries - provide full paths to .so or .a files\n    ${CMAKE_CURRENT_LIST_DIR}/lib/libarena.so          # Core Arena library\n    ${CMAKE_CURRENT_LIST_DIR}/lib/libsavec.so          # Save functionality\n    ${CMAKE_CURRENT_LIST_DIR}/lib/libgentl.so          # GenTL functionality\n    ${CMAKE_CURRENT_LIST_DIR}/lib/liblucidlog.so       # Lucid logging\n    ${CMAKE_CURRENT_LIST_DIR}/lib/libsave.so\n    ${CMAKE_CURRENT_LIST_DIR}/lib/libarenac.so\n\n    ${CMAKE_CURRENT_LIST_DIR}/ffmpeg/libavcodec.so\n    ${CMAKE_CURRENT_LIST_DIR}/ffmpeg/libavformat.so\n    ${CMAKE_CURRENT_LIST_DIR}/ffmpeg/libavutil.so\n    ${CMAKE_CURRENT_LIST_DIR}/ffmpeg/libswresample.so\n\n\n    # GenICam libraries\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libGenApi_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libGCBase_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libMathParser_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/liblog4cpp_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libLog_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libNodeMapData_gcc54_v3_3_LUCID.so\n    ${CMAKE_CURRENT_LIST_DIR}/GenICam/library/lib/Linux64_ARM/libXmlParser_gcc54_v3_3_LUCID.so\n)\n</code></pre> <ol> <li>In <code>scales-software/Components/RunLucidCamera/RunLucidCamera.cpp</code>, update the include path to <code>#include \"ArenaApi.h\"</code> and <code>#include SaveApi.h</code>, and integrate the <code>CppSave_Png.cpp</code> example code from the Arena SDK into the <code>RunLucidCamera.cpp</code>. The constructor and deconstructor for the component was modified to include parts of the Arena SDK example code. We also modified the way the example code was saving the images so the old images don't get overwritten. The current code is here. </li> </ol>"},{"location":"scales_demo/#progress","title":"Progress","text":"<p>Currently, the IMX can command the Jetson through the Hub Pattern to take a picture using the ethernet camera. We are running into some connectivity issues with the Hub Pattern which will be worked out soon. </p> <p>Next Steps:</p> <ul> <li>Fix connectivity issues with the Hub Pattern</li> <li>Run Machine Learning algorithms on the pictures taken with the camera</li> <li>Eventually run on custom hardware</li> </ul>"},{"location":"meeting_notes/feb_21_25/","title":"Feb 21 25","text":""},{"location":"meeting_notes/feb_21_25/#andrew-greenberg-feb-21-2025-notes","title":"Andrew Greenberg Feb 21 2025 Notes","text":"<p>During this technical exchange call with Andrew Greenberg we discussed Luca's Power Circuit and the use of SatCat5 in the SCALES system.</p> <ul> <li>There needs to be a power input spec! Right now the design is arbitrary without it</li> <li>When the power regulator goes nuts do you want it connected to the load switch or to the 28V input? </li> <li>If the put the load switch first, you have the chance to protect your input voltage from a downstream voltage regulator</li> <li>It would be possible to derate the voltage regulators a bit if we use some kind of soft start capability on the Jetson</li> <li>We need to know three things: <ul> <li>Idle Current</li> <li>Max Operational Average Current</li> <li>Max Transient Current</li> </ul> </li> <li>A Watchdog failure\u2019s fault tree can lead to loss of mission<ul> <li>Taking away that fault tree is better than maybe bringing in slightly more reliability</li> </ul> </li> <li>Using idealized schematic symbols rather than a package symbol in the schematic is generally better</li> <li>Point the grounds down and the voltage sources up!</li> <li>Separate sheet for each voltage regulator is a good idea!</li> <li>It\u2019s probably better to just switch to a load switch with integrated over current protection rather than relying on the power monitor to go into software (software people will leave you out to dry)</li> <li>For under-voltage we need to circle back to the question of what that means for the input</li> <li>We should make sure to power up in non-clock mode and then sync at a later time rather than having to immediately sync<ul> <li>This is really for noise shaping (so you can control where your EMI is)</li> </ul> </li> <li>With regards to slew rates: we need to determine what happens if the clock crystals go crazy and lock up the regulators<ul> <li>The regulators should fall back to RT if the clock lock up (TEST THIS)</li> <li>You can mess with this using an eval board</li> </ul> </li> <li>Tantalum caps have a high inductance in series (this is why you mix big and small capacitors)</li> <li>Generate the reset timing with an automotive Schmitt Trigger with an RC clock</li> </ul> <p>No notes were taken, but we decided to descope SatCat5 from the SCALES system due to the likelihood that it becomes an engineering quagmire.</p>"}]}